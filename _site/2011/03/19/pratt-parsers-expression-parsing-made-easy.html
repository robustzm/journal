<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro|PT+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>

    <!-- Tell mobile browsers we're optimized for them and they don't need to
         crop the viewport. -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
    <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/rss.xml" />
    <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/atom.xml" />
    <link rel="stylesheet" href="/style.css" type="text/css" />

    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

    <title>
      Pratt Parsers: Expression Parsing Made Easy
      
        &ndash; journal.stuffwithstuff.com
      
    </title>
  </head>
  <body>
    <div class="column">
      
<article>
<header>
<h1>
  <a href="/2011/03/19/pratt-parsers-expression-parsing-made-easy" rel="bookmark"
     title="Permanent Link to Pratt Parsers: Expression Parsing Made Easy">
    Pratt Parsers: Expression Parsing Made Easy
  </a>
</h1>

  <a class="older" href="/2011/02/13/extending-syntax-from-within-a-language"
     title="Older Post &ldquo;Extending Syntax from Within a Language&rdquo;">&#8617;</a>


  <a class="newer" href="/2011/04/21/multimethods-multiple-inheritance-multiawesome"
     title="Newer Post &ldquo;Multimethods, Multiple Inheritance, Multiawesome!&rdquo;">&#8618;</a>

</header>
<h4><a href="/archive">March 19, 2011</a>
    <span class="tags"><a href="/category/code">code</a> <a href="/category/java">java</a> <a href="/category/js">js</a> <a href="/category/language">language</a> <a href="/category/magpie">magpie</a> <a href="/category/parsing">parsing</a></span>
</h4>

<p>Every now and then, I stumble onto some algorithm or idea that&rsquo;s so clever and
such a perfect solution to a problem that I feel like I got smarter or gained
<a href="http://xkcd.com/208/">a new superpower</a> just by learning it. <a href="http://en.wikipedia.org/wiki/Heap_%28data_structure%29">Heaps</a> (just about the only
thing I got out of my truncated CS education) were one thing like this. I
recently stumbled onto another: <a href="http://en.wikipedia.org/wiki/Vaughan_Pratt">Pratt</a> parsers.</p>

<p>When you&rsquo;re writing a parser, <a href="http://en.wikipedia.org/wiki/Recursive_descent">recursive descent</a> is as easy as spreading
peanut butter. It excels when you can figure out what to do next based on the
next chunk of code you&rsquo;re parsing. That&rsquo;s usually true at the top level of a
language where things like classes are and also for statements since most
start with something that uniquely identifies them (<code>if</code>, <code>for</code>, <code>while</code>,
etc.).</p>

<p>But it gets tricky when you get to expressions. When it comes to infix
operators like <code>+</code>, postfix ones like <code>++</code>, and even mixfix expressions like
<code>?:</code>, it can be hard to tell what kind of expression you&rsquo;re parsing until
you&rsquo;re halfway through it. You <em>can</em> do this with recursive descent, but it&rsquo;s
a chore. You have to write separate functions for each level of precedence
(JavaScript has 17 of them, for example), manually handle associativity, and
smear your grammar across a bunch of parsing code until it&rsquo;s hard to see.</p>

<h2>PB &amp; J, The Secret Weapon</h2>

<p>Pratt parsing fixes just that. If recursive descent is peanut butter, Pratt
parsing is jelly. When you mix the two together, you get a simple, terse,
readable parser that can handle any grammar you throw at it.</p>

<p>Pratt&rsquo;s technique for handling operator precedence and infix expressions is so
simple and effective it&rsquo;s a mystery why almost no one knows about it. After
the seventies, top down operator precedence parsers seem to have fallen off
the Earth. Douglas Crockford&rsquo;s <a href="http://www.jslint.com/">JSLint</a> uses one to <a href="http://javascript.crockford.com/tdop/tdop.html">parse
JavaScript</a>, but his treatment is one of the <a href="http://effbot.org/zone/simple-top-down-parsing.htm">very few</a> remotely
modern articles about it.</p>

<p>Part of the problem, I think, is that Pratt&rsquo;s terminology is opaque, and
Crockford&rsquo;s article is itself rather murky. Pratt uses terms like &ldquo;null
denominator&rdquo; and Crockford mixes in extra stuff like tracking lexical scope
that obscures the core idea.</p>

<p>This is where I come in. I won&rsquo;t do anything revolutionary. I&rsquo;ll just try to
get the core concepts behind top down operator precedence parsers and present
them as clearly as I can. I&rsquo;ll switch out some terms to (I hope) clarify
things. Hopefully I won&rsquo;t offend anyone&rsquo;s purist sensibilities. I&rsquo;ll be coding
in Java, the vulgar Latin of programming languages. I figure if you can write
it in Java, you can write it in anything.</p>

<h2>What We&rsquo;ll Be Making</h2>

<p>I&rsquo;m a learn-by-doing person, which means I&rsquo;m also a teach-by-doing one. So to
show how Pratt parsers work, we&rsquo;ll build a parser for a <a href="https://github.com/munificent/bantam">tiny little toy
language called <em>Bantam</em></a>. It just has expressions since that&rsquo;s where
Pratt parsing is really helpful, but that should be enough to convince of its
usefulness.</p>

<p>Even though it&rsquo;s simple, it has a full gamut of operators: prefix (<code>+</code>, <code>-</code>,
<code>~</code>, <code>!</code>), postfix (<code>!</code>), infix (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>), and even a mixfix
conditional operator (<code>?:</code>). It has multiple precedence levels and both right
and left associative operators. It also has assignment, function calls and
parentheses for grouping. If we can parse this, we can parse anything.</p>

<h2>What We&rsquo;ll Start With</h2>

<p>All we care about is parsing, so we&rsquo;ll ignore the tokenizing phase. I slapped
together <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Lexer.java">a crude lexer</a> that works and we&rsquo;ll just pretend that tokens are
raining down from heaven or something.</p>

<p>A token is just a chunk of meaningful code with a type and a string associated
with it. Given <code>a + b(c)</code>, the tokens would be:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>NAME &quot;a&quot;
PLUS &quot;+&quot;
NAME &quot;b&quot;
LEFT_PAREN &quot;(&quot;
NAME &quot;c&quot;
RIGHT_PAREN &quot;)&quot;
</code></pre></div>
<p>Likewise, we won&rsquo;t be <em>interpreting</em> or <em>compiling</em> this code. We just want to
parse it to a nice data structure. For our purposes, that means our parser
should chew up a bunch of <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Token.java"><code>Token</code></a> objects and spit out an instance of
some class that implements <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/expressions/Expression.java"><code>Expression</code></a>. To give you an idea, here&rsquo;s a
simplified version of the class for a <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/expressions/ConditionalExpression.java">conditional expression</a>:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">class</span> <span class="nc">ConditionalExpression</span> <span class="kd">implements</span> <span class="n">Expression</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nf">ConditionalExpression</span><span class="o">(</span>
      <span class="n">Expression</span> <span class="n">condition</span><span class="o">,</span>
      <span class="n">Expression</span> <span class="n">thenArm</span><span class="o">,</span>
      <span class="n">Expression</span> <span class="n">elseArm</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">condition</span> <span class="o">=</span> <span class="n">condition</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">thenArm</span>   <span class="o">=</span> <span class="n">thenArm</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">elseArm</span>   <span class="o">=</span> <span class="n">elseArm</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">final</span> <span class="n">Expression</span> <span class="n">condition</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">final</span> <span class="n">Expression</span> <span class="n">thenArm</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">final</span> <span class="n">Expression</span> <span class="n">elseArm</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>(You gotta love Java&rsquo;s &ldquo;please sign it in quadruplicate&rdquo; level of bureaucracy
here. Like I said, if you can do this in Java, you can do it in <em>any</em>
language.)</p>

<p>We&rsquo;ll be building this starting from a simple <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Parser.java"><code>Parser</code></a> class. This owns
the token stream, handles lookahead and provides the basic methods you&rsquo;ll need
to write a top-down recursive descent parser with a single token of lookahead
(i.e. it&rsquo;s LL(1)). This is enough to get us going. If we need more later, it&rsquo;s
easy to extend it.</p>

<p>OK, let&rsquo;s build ourselves a parser!</p>

<h2>First Things First</h2>

<p>Even though a &ldquo;full&rdquo; Pratt parser is pretty tiny, I found it to be a bit hard
to decipher. Sort of like <a href="http://en.wikipedia.org/wiki/Quicksort">quicksort</a>,
the implementation is a deceptively-simple handful of deeply intertwined code.
To untangle it, we&rsquo;ll build it up one tiny step at a time.</p>

<p>The simplest expressions to parse are prefix operators and single-token ones.
For those, the current token tells us all that we need to do. Bantam has one
single-token expression, named variables, and four prefix operators: <code>+</code>, <code>-</code>,
<code>~</code>, and <code>!</code>. The simplest possible code to parse that would be:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="n">Expression</span> <span class="nf">parseExpression</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">NAME</span><span class="o">))</span>       <span class="c1">// return NameExpression...</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">PLUS</span><span class="o">))</span>  <span class="c1">// return prefix + operator...</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">MINUS</span><span class="o">))</span> <span class="c1">// return prefix - operator...</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">TILDE</span><span class="o">))</span> <span class="c1">// return prefix ~ operator...</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">match</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">BANG</span><span class="o">))</span>  <span class="c1">// return prefix ! operator...</span>
  <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ParseException</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>But that&rsquo;s a bit monolithic. As you can see, we&rsquo;re switching off of a
<code>TokenType</code> to branch to different parsing behavior. Let&rsquo;s encode that
directly by making a <code>Map</code> from <code>TokenTypes</code> to chunks of parsing code. We&rsquo;ll
call these chunks &ldquo;parselets&rdquo;, and they will implement this:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">interface</span> <span class="nc">PrefixParselet</span> <span class="o">{</span>
  <span class="n">Expression</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Parser</span> <span class="n">parser</span><span class="o">,</span> <span class="n">Token</span> <span class="n">token</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>An implementation of this to parse variable names is just:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">class</span> <span class="nc">NameParselet</span> <span class="kd">implements</span> <span class="n">PrefixParselet</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Expression</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Parser</span> <span class="n">parser</span><span class="o">,</span> <span class="n">Token</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">NameExpression</span><span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>We can use a single class for all of the prefix operators since they only
differ in the actual operator token itself:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">class</span> <span class="nc">PrefixOperatorParselet</span> <span class="kd">implements</span> <span class="n">PrefixParselet</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Expression</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Parser</span> <span class="n">parser</span><span class="o">,</span> <span class="n">Token</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Expression</span> <span class="n">operand</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="na">parseExpression</span><span class="o">();</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">PrefixExpression</span><span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">getType</span><span class="o">(),</span> <span class="n">operand</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>You&rsquo;ll note that it calls back into <code>parseExpression()</code> to parse the operand
that appears after the operator (i.e. to parse the <code>a</code> in <code>-a</code>). This
recursion takes care of nested operators like <code>-+~!a</code>.</p>

<p>Back in <code>Parser</code>, the chained <code>if</code> statements are replaced with a cleaner map:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">class</span> <span class="nc">Parser</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">register</span><span class="o">(</span><span class="n">TokenType</span> <span class="n">token</span><span class="o">,</span> <span class="n">PrefixParselet</span> <span class="n">parselet</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">mPrefixParselets</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">token</span><span class="o">,</span> <span class="n">parselet</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">Expression</span> <span class="nf">parseExpression</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Token</span> <span class="n">token</span> <span class="o">=</span> <span class="n">consume</span><span class="o">();</span>
    <span class="n">PrefixParselet</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">mPrefixParselets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ParseException</span><span class="o">(</span>
        <span class="s">&quot;Could not parse \&quot;&quot;</span> <span class="o">+</span> <span class="n">token</span><span class="o">.</span><span class="na">getText</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;\&quot;.&quot;</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">prefix</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">token</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="c1">// Other stuff...</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">TokenType</span><span class="o">,</span> <span class="n">PrefixParselet</span><span class="o">&gt;</span> <span class="n">mPrefixParselets</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">TokenType</span><span class="o">,</span> <span class="n">PrefixParselet</span><span class="o">&gt;();</span>
<span class="o">}</span>
</code></pre></div>
<p>To define the grammar we have so far (variables and the four prefix
operators), we&rsquo;ll make this helper method:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kt">void</span> <span class="nf">prefix</span><span class="o">(</span><span class="n">TokenType</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">register</span><span class="o">(</span><span class="n">token</span><span class="o">,</span> <span class="k">new</span> <span class="n">PrefixOperatorParselet</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div>
<p>And now we can define the grammar like:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="n">register</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">NAME</span><span class="o">,</span> <span class="k">new</span> <span class="n">NameParselet</span><span class="o">());</span>
<span class="n">prefix</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">PLUS</span><span class="o">);</span>
<span class="n">prefix</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">MINUS</span><span class="o">);</span>
<span class="n">prefix</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">TILDE</span><span class="o">);</span>
<span class="n">prefix</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">BANG</span><span class="o">);</span>
</code></pre></div>
<p>This is already an improvement over a recursive descent parser because our
grammar is now more declarative instead of being spread out over a few
imperative functions, and we can see the actual grammar all in one place. Even
better, we can extend the grammar just by registering new parselets. We don&rsquo;t
have to change the <code>Parser</code> class itself.</p>

<p>If we <em>only</em> had prefix expressions, we&rsquo;d be done now. Alas, we don&rsquo;t.</p>

<h2>Stuck In the Middle</h2>

<p>What we have so far only works if the <em>first</em> token tells us what kind of
expression we&rsquo;re parsing, but that isn&rsquo;t always the case. With an expression
like <code>a + b</code>, we don&rsquo;t know we have an add expression until after we parse the
<code>a</code> and get to <code>+</code>. We&rsquo;ll have to extend the parser to support that.</p>

<p>Fortunately, we&rsquo;re in a good place to do so. Our current <code>parseExpression()</code>
method will parse a complete prefix expression including any nested prefix
expressions and then stop. So, if we throw this at it:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="o">-</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div>
<p>It will parse <code>-a</code> and leave us sitting on <code>+</code>. That&rsquo;s exactly the token we
need to tell what infix expression we&rsquo;re parsing. The only difference between
an infix expression and a prefix one here is that there&rsquo;s another expression
<em>before</em> the infix operator that it needs to have as an argument. Let&rsquo;s define
a parselet that supports that:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">interface</span> <span class="nc">InfixParselet</span> <span class="o">{</span>
  <span class="n">Expression</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Parser</span> <span class="n">parser</span><span class="o">,</span> <span class="n">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="n">Token</span> <span class="n">token</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>The only difference is that <code>left</code> argument, which is just the expression we
parsed before we got to the infix token. We&rsquo;ll wire this up to our parser by
having another table of infix parselets.</p>

<p>Having separate tables for prefix and infix expressions is important because
we&rsquo;ll often have both a prefix and infix parselet for a single <code>TokenType</code>. For
example, the prefix parselet for <code>(</code> handles grouping in an expression like <code>a
* (b + c)</code>. Meanwhile, the <em>infix</em> parselet handles function calls like
<code>a(b)</code>.</p>

<p>Now, after we parse the prefix expression, we hand it off to any infix one
that subsumes it:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">class</span> <span class="nc">Parser</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">register</span><span class="o">(</span><span class="n">TokenType</span> <span class="n">token</span><span class="o">,</span> <span class="n">InfixParselet</span> <span class="n">parselet</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">mInfixParselets</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">token</span><span class="o">,</span> <span class="n">parselet</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">Expression</span> <span class="nf">parseExpression</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Token</span> <span class="n">token</span> <span class="o">=</span> <span class="n">consume</span><span class="o">();</span>
    <span class="n">PrefixParselet</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">mPrefixParselets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ParseException</span><span class="o">(</span>
        <span class="s">&quot;Could not parse \&quot;&quot;</span> <span class="o">+</span> <span class="n">token</span><span class="o">.</span><span class="na">getText</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;\&quot;.&quot;</span><span class="o">);</span>

    <span class="n">Expression</span> <span class="n">left</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">token</span><span class="o">);</span>

    <span class="n">token</span> <span class="o">=</span> <span class="n">lookAhead</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">InfixParselet</span> <span class="n">infix</span> <span class="o">=</span> <span class="n">mInfixParselets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span>

    <span class="c1">// No infix expression at this point, so we&#39;re done.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">infix</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">left</span><span class="o">;</span>

    <span class="n">consume</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">infix</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">token</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="c1">// Other stuff...</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">TokenType</span><span class="o">,</span> <span class="n">InfixParselet</span><span class="o">&gt;</span> <span class="n">mInfixParselets</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">TokenType</span><span class="o">,</span> <span class="n">InfixParselet</span><span class="o">&gt;();</span>
<span class="o">}</span>
</code></pre></div>
<p>Pretty straightforward. We can implement an infix parselet for binary
arithmetic operators like <code>+</code> using something like:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">class</span> <span class="nc">BinaryOperatorParselet</span> <span class="kd">implements</span> <span class="n">InfixParselet</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Expression</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Parser</span> <span class="n">parser</span><span class="o">,</span>
      <span class="n">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="n">Token</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Expression</span> <span class="n">right</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="na">parseExpression</span><span class="o">();</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">OperatorExpression</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">token</span><span class="o">.</span><span class="na">getType</span><span class="o">(),</span> <span class="n">right</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>This also works for postfix operators. I&rsquo;m calling them &ldquo;infix&rdquo; parselets, but
they&rsquo;re really &ldquo;anything but prefix&rdquo;. If there&rsquo;s some expression that comes
before the token, it will be handled by an infix parselet, and that includes
postfix expressions and mixfix ones like <code>?:</code>.</p>

<p>Postfix is as easy as a single-token prefix parselet: it just takes the <code>left</code>
expression and wraps it in another expression:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">class</span> <span class="nc">PostfixOperatorParselet</span> <span class="kd">implements</span> <span class="n">InfixParselet</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Expression</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Parser</span> <span class="n">parser</span><span class="o">,</span> <span class="n">Expression</span> <span class="n">left</span><span class="o">,</span>
      <span class="n">Token</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">PostfixExpression</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">token</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Mixfix is easy too. It&rsquo;s pretty much a familiar recursive descent parser:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">class</span> <span class="nc">ConditionalParselet</span> <span class="kd">implements</span> <span class="n">InfixParselet</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Expression</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Parser</span> <span class="n">parser</span><span class="o">,</span> <span class="n">Expression</span> <span class="n">left</span><span class="o">,</span>
      <span class="n">Token</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Expression</span> <span class="n">thenArm</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="na">parseExpression</span><span class="o">();</span>
    <span class="n">parser</span><span class="o">.</span><span class="na">consume</span><span class="o">(</span><span class="n">TokenType</span><span class="o">.</span><span class="na">COLON</span><span class="o">);</span>
    <span class="n">Expression</span> <span class="n">elseArm</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="na">parseExpression</span><span class="o">();</span>

    <span class="k">return</span> <span class="k">new</span> <span class="n">ConditionalExpression</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">thenArm</span><span class="o">,</span> <span class="n">elseArm</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Now we can parse prefix expressions, postfix, infix, and even mixfix. With a
pretty small amount of code, we can parse expressions like <code>a + (b ? c! :
-d)</code>. We&rsquo;re done, right? Well… almost.</p>

<h2>Excuse You, Aunt Sally</h2>

<p>Our parser <em>can</em> parse all of this stuff, but it doesn&rsquo;t parse it with the
right precedence or associativity. If you throw <code>a - b - c</code> at it, it will
parse it like <code>a - (b - c)</code>, which isn&rsquo;t right. (Well, actually it is
<em>right</em>&mdash;associative that is. We need it to be <em>left</em>.)</p>

<p>And this <em>last</em> step is where Pratt parsers go from pretty nice to totally
radical. We&rsquo;ll make two simple changes. We&rsquo;ll extend <code>parseExpression()</code> to
take a <em>precedence</em>&mdash;a number that tells which expressions can be parsed by
that call. If it encounters an expression whose precedence is lower than we
allow, it just stops parsing and returns what it has so far.</p>

<p>To make that check we need to know the precedence of any given infix
expression. We&rsquo;ll do that by letting the parselet specify it:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">InfixParselet</span> <span class="o">{</span>
  <span class="n">Expression</span> <span class="nf">parse</span><span class="o">(</span><span class="n">Parser</span> <span class="n">parser</span><span class="o">,</span> <span class="n">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="n">Token</span> <span class="n">token</span><span class="o">);</span>
  <span class="kt">int</span> <span class="nf">getPrecedence</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>Using that, our core expression parser becomes:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="n">Expression</span> <span class="nf">parseExpression</span><span class="o">(</span><span class="kt">int</span> <span class="n">precedence</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Token</span> <span class="n">token</span> <span class="o">=</span> <span class="n">consume</span><span class="o">();</span>
  <span class="n">PrefixParselet</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">mPrefixParselets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ParseException</span><span class="o">(</span>
      <span class="s">&quot;Could not parse \&quot;&quot;</span> <span class="o">+</span> <span class="n">token</span><span class="o">.</span><span class="na">getText</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;\&quot;.&quot;</span><span class="o">);</span>

  <span class="n">Expression</span> <span class="n">left</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">token</span><span class="o">);</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">precedence</span> <span class="o">&lt;</span> <span class="n">getPrecedence</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">token</span> <span class="o">=</span> <span class="n">consume</span><span class="o">();</span>

    <span class="n">InfixParselet</span> <span class="n">infix</span> <span class="o">=</span> <span class="n">mInfixParselets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">token</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">infix</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">token</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>That relies on a tiny helper function to get the precedence of the current
token or default if there&rsquo;s no infix parselet for it:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">private</span> <span class="kt">int</span> <span class="nf">getPrecedence</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">InfixParselet</span> <span class="n">parser</span> <span class="o">=</span> <span class="n">mInfixParselets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span>
      <span class="n">lookAhead</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">getType</span><span class="o">());</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">parser</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="na">getPrecedence</span><span class="o">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>And that&rsquo;s it. To use this, we&rsquo;ll set up a little precedence table:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Precedence</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ASSIGNMENT</span>  <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CONDITIONAL</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SUM</span>         <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">PRODUCT</span>     <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">EXPONENT</span>    <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">PREFIX</span>      <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">POSTFIX</span>     <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CALL</span>        <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
<p>To make our operators correctly handle precedence, they&rsquo;ll pass an appropriate
value back into <code>parseExpression()</code> when they call it recursively. For
example, the <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/parselets/BinaryOperatorParselet.java"><code>BinaryOperatorParselet</code></a> instance that handles the <code>+</code>
operator will pass in <code>Precedence.SUM</code> when it parses its right-hand operand.</p>

<p>Associativity is easy too. If an infix parselet calls <code>parseExpression()</code> with
the <em>same</em> precedence that it returns for its own <code>getPrecedence()</code> call,
you&rsquo;ll get left associativity. To be right-associative, it just needs to pass
in <em>one less</em> than that instead.</p>

<h2>Go Forth and Multiply</h2>

<p>I&rsquo;ve rewritten the <a href="https://github.com/munificent/magpie/blob/master/src/com/stuffwithstuff/magpie/parser/MagpieParser.java">parser for Magpie</a> using this and it worked like a
charm. I&rsquo;m also working on a JavaScript parser based on this and again it&rsquo;s
been a great fit.</p>

<p>I find parsing like this to be simple, terse, extensible (Magpie, for example,
uses this to <a href="http://journal.stuffwithstuff.com/2011/02/13/extending-syntax-from-within-a-language/">let you extend its own syntax</a> at runtime), and easy to
read. I&rsquo;m at the point where I can&rsquo;t imagine writing a parser any other way. I
never thought I&rsquo;d say this, but parsers are easy now.</p>

<p>To see for yourself, just take a look at <a href="http://github.com/munificent/bantam">the complete program</a>.</p>

  <div class="social">
    <a href="//www.reddit.com/submit?url=http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/" target="_blank">
      <i class="fa fa-lg fa-reddit-square"></i>
    </a>

    <a href="//news.ycombinator.com/submitlink?u=http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/&amp;t=Pratt Parsers: Expression Parsing Made Easy" target="_blank">
      <i class="fa fa-lg fa-hacker-news"></i>
    </a>

    <a href="http://twitter.com/share?url=http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy&amp;text=%22Pratt Parsers: Expression Parsing Made Easy%22%20%40munificentbob" target="_blank">
      <i class="fa fa-lg fa-twitter-square"></i>
    </a>

    <a href="http://www.facebook.com/share.php?u=http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy" target="_blank">
      <i class="fa fa-lg fa-facebook-square"></i>
    </a>

    <a href="https://plus.google.com/share?url=http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy" target="_blank">
      <i class="fa fa-lg fa-google-plus-square"></i>
    </a>

    <a href="/rss.xml">
      <i class="fa fa-lg fa-rss-square"></i>
    </a>
  </div>

  
  <div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'journal-stuffwithstuff';
        var disqus_url = "http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy";

        (function() {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</article>


      <nav>
  <div class="nav-first">
    <a href="/"><img src="/image/dogshot_square.jpg" class="bob"></a>

    <p>Hi! I'm <strong>Bob Nystrom</strong>, the one on the left.</p>
    <p>I wrote a book called <a href="http://gameprogrammingpatterns.com/"><strong>Game Programming Patterns</strong></a>. I'm working on another book called
    <a href="http://craftinginterpreters.com">Crafting Interpreters</a></p>
    <p>You can email me at <code>robert</code> at this site or follow me on twitter at <a href="https://twitter.com/intent/user?screen_name=munificentbob"><code>@munificentbob</code></a>.</p>

    <h2>Elsewhere</h2>
    <ul>
      <li>Code at <a href="http://github.com/munificent">github</a></li>
      <li>Tweets at <a href="http://twitter.com/munificentbob">twitter</a></li>
      <li>Photos at <a href="https://500px.com/munificent">500px</a></li>
      <li>Photos at <a href="http://www.flickr.com/photos/bobisbob/">flickr</a></li>
    </ul>
  </div>
  <div class="nav-second">
    <h2>Categories</h2>
    <ul><li><a href="/category/code">code</a> <small class='post-count'>67</small></li><li><a href="/category/language">language</a> <small class='post-count'>41</small></li><li><a href="/category/magpie">magpie</a> <small class='post-count'>24</small></li><li><a href="/category/c-sharp">c-sharp</a> <small class='post-count'>13</small></li><li><a href="/category/dart">dart</a> <small class='post-count'>13</small></li><li><a href="/category/game-dev">game-dev</a> <small class='post-count'>12</small></li><li><a href="/category/java">java</a> <small class='post-count'>10</small></li><li><a href="/category/cpp">cpp</a> <small class='post-count'>8</small></li><li><a href="/category/game-patterns">game-patterns</a> <small class='post-count'>6</small></li><li><a href="/category/parsing">parsing</a> <small class='post-count'>6</small></li><li><a href="/category/roguelike">roguelike</a> <small class='post-count'>6</small></li><li><a href="/category/design">design</a> <small class='post-count'>5</small></li><li><a href="/category/go">go</a> <small class='post-count'>5</small></li><li><a href="/category/js">js</a> <small class='post-count'>4</small></li><li><a href="/category/book">book</a> <small class='post-count'>3</small></li><li><a href="/category/c">c</a> <small class='post-count'>3</small></li><li><a href="/category/finch">finch</a> <small class='post-count'>3</small></li><li><a href="/category/python">python</a> <small class='post-count'>3</small></li><li><a href="/category/ruby">ruby</a> <small class='post-count'>3</small></li><li><a href="/category/blog">blog</a> <small class='post-count'>2</small></li><li><a href="/category/f-sharp">f-sharp</a> <small class='post-count'>2</small></li><li><a href="/category/lua">lua</a> <small class='post-count'>2</small></li><li><a href="/category/music">music</a> <small class='post-count'>2</small></li><li><a href="/category/ai">ai</a> <small class='post-count'>1</small></li><li><a href="/category/beta">beta</a> <small class='post-count'>1</small></li><li><a href="/category/blogofile">blogofile</a> <small class='post-count'>1</small></li><li><a href="/category/game">game</a> <small class='post-count'>1</small></li><li><a href="/category/jasic">jasic</a> <small class='post-count'>1</small></li><li><a href="/category/javascript">javascript</a> <small class='post-count'>1</small></li><li><a href="/category/oop">oop</a> <small class='post-count'>1</small></li><li><a href="/category/optimization">optimization</a> <small class='post-count'>1</small></li><li><a href="/category/oscon">oscon</a> <small class='post-count'>1</small></li><li><a href="/category/politics">politics</a> <small class='post-count'>1</small></li><li><a href="/category/scheme">scheme</a> <small class='post-count'>1</small></li><li><a href="/category/typescript">typescript</a> <small class='post-count'>1</small></li><li><a href="/category/visualization">visualization</a> <small class='post-count'>1</small></li></ul>

    <p class="archive">All <a href="/archive">74 articles</a>&hellip;</p>

    <p>This blog is built using <a href="http://jekyllrb.com/">jekyll</a>. The source repo for it is <a href="https://github.com/munificent/journal">here</a>.</p>
    <p class="copyright">&copy; 2008-2014 Robert Nystrom</p>
  </div>
</nav>
    </div>
  </body>
</html>
