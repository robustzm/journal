# [journal.

stuffwithstuff.com][1]

   [1]: http://journal.stuffwithstuff.com/

## me

  * [bob nystrom][2] is me
  * [bitbucket][3] has code
  * [github][4] has code
  * [flickr][5] has photos
  * [twitter][6] has status
  * [vimeo][7] has video

   [2]: http://www.stuffwithstuff.com/bob-nystrom.html
   [3]: http://bitbucket.org/munificent/
   [4]: http://github.com/munificent/
   [5]: http://www.flickr.com/photos/bobisbob/
   [6]: http://twitter.com/munificentbob
   [7]: http://vimeo.com/bobisbob

## archives

  * [2011][8]
  * [2010][9]
  * [2009][10]
  * [2008][11]

   [8]: http://journal.stuffwithstuff.com/2011/ (2011)
   [9]: http://journal.stuffwithstuff.com/2010/ (2010)
   [10]: http://journal.stuffwithstuff.com/2009/ (2009)
   [11]: http://journal.stuffwithstuff.com/2008/ (2008)

## tags

  * [blog][12] (2)
  * [c#][13] (13)
  * [code][14] (48)
  * [cpp][15] (7)
  * [design][16] (3)
  * [f#][17] (2)
  * [finch][18] (3)
  * [game-dev][19] (6)
  * [game-patterns][20] (3)
  * [go][21] (2)
  * [jasic][22] (1)
  * [java][23] (10)
  * [javascript][24] (3)
  * [language][25] (29)
  * [magpie][26] (19)
  * [optimization][27] (1)
  * [oscon][28] (1)
  * [parsing][29] (7)
  * [politics][30] (1)
  * [python][31] (2)
  * [roguelike][32] (2)
  * [ruby][33] (1)
  * [sml][34] (1)
  * [visualization][35] (1)

   [12]: http://journal.stuffwithstuff.com/category/blog/ (View all posts filed under blog)
   [13]: http://journal.stuffwithstuff.com/category/c/ (View all posts filed under c#)
   [14]: http://journal.stuffwithstuff.com/category/code/ (View all posts filed under code)
   [15]: http://journal.stuffwithstuff.com/category/cpp/ (View all posts filed under cpp)
   [16]: http://journal.stuffwithstuff.com/category/design/ (View all posts filed under design)
   [17]: http://journal.stuffwithstuff.com/category/f/ (View all posts filed under f#)
   [18]: http://journal.stuffwithstuff.com/category/finch/ (View all posts filed under finch)
   [19]: http://journal.stuffwithstuff.com/category/game-dev/ (View all posts filed under game-dev)
   [20]: http://journal.stuffwithstuff.com/category/game-patterns/ (View all posts filed under game-patterns)
   [21]: http://journal.stuffwithstuff.com/category/go/ (View all posts filed under go)
   [22]: http://journal.stuffwithstuff.com/category/jasic/ (View all posts filed under jasic)
   [23]: http://journal.stuffwithstuff.com/category/java/ (View all posts filed under java)
   [24]: http://journal.stuffwithstuff.com/category/javascript/ (View all posts filed under javascript)
   [25]: http://journal.stuffwithstuff.com/category/language/ (View all posts filed under language)
   [26]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts filed under magpie)
   [27]: http://journal.stuffwithstuff.com/category/optimization/ (View all posts filed under optimization)
   [28]: http://journal.stuffwithstuff.com/category/oscon/ (View all posts filed under oscon)
   [29]: http://journal.stuffwithstuff.com/category/parsing/ (View all posts filed under parsing)
   [30]: http://journal.stuffwithstuff.com/category/politics/ (View all posts filed under politics)
   [31]: http://journal.stuffwithstuff.com/category/python/ (View all posts filed under python)
   [32]: http://journal.stuffwithstuff.com/category/roguelike/ (View all posts filed under roguelike)
   [33]: http://journal.stuffwithstuff.com/category/ruby/ (View all posts filed under ruby)
   [34]: http://journal.stuffwithstuff.com/category/sml/ (View all posts filed under sml)
   [35]: http://journal.stuffwithstuff.com/category/visualization/ (View all posts filed under visualization)

## info

  * [famfamfam][36] provides icons
  * [RSS][37] syndicates me
  * [WordPress][38] powers me

   [36]: http://famfamfam.com/lab/icons/silk/
   [37]: feed:http://journal.stuffwithstuff.com/feed/
   [38]: http://wordpress.org/

## [Using an Iterator as a Game Loop][39]

   [39]: http://journal.stuffwithstuff.com/2008/11/17/using-an-iterator-as-a-game-loop/ (Using an Iterator as a Game Loop)

[c#][40] | [code][41] | [game-dev][42] | [roguelike][43] [2008][44] / [11][45]
/ [17][46]

   [40]: http://journal.stuffwithstuff.com/category/c/ (View all posts in c#)
   [41]: http://journal.stuffwithstuff.com/category/code/ (View all posts in code)
   [42]: http://journal.stuffwithstuff.com/category/game-dev/ (View all posts in game-dev)
   [43]: http://journal.stuffwithstuff.com/category/roguelike/ (View all posts in roguelike)
   [44]: http://journal.stuffwithstuff.com/2008/ (year)
   [45]: http://journal.stuffwithstuff.com/2008/11/ (month)
   [46]: http://journal.stuffwithstuff.com/2008/11/17/

If you've ever worked on a game before (and if you code, you probably have, at
least on your own), you've seen the [venerable game loop][47]. It's the core
loop in the executable that iterates as long as the game is running. In GUI
apps, an [event loop][48] accomplishes the same goal of keeping the executable
running indefinitely. A simple game loop looks like:


       [47]: http://dewitters.koonsolo.com/gameloop.html
   [48]: http://en.wikipedia.org/wiki/Event_loop

    void GameLoop()
    {
        while (mPlaying)
        {
            HandleUserInput();
            UpdateGameState();
            Render();
        }
    }

Pretty straightforward, and it's endearing to know that even the most advanced
blockbuster game on the market has some code quite similar to this in it
somewhere.

### Separating out the UI

However, my game project is a [turn-based roguelike][49]. This means
`HandleUserInput()` blocks indefinitely until the user has chosen a move.
Also, I'm a design purist, so I want to not have engine code (which is where
the game loop lives) directly call into UI-land code (`HandleUserInput()`).
Right now the game is ASCII, but if I ever add graphics I don't want to change
the engine.

   [49]: http://rephial.org/

So what I did was move the loop back into UI-land (i.e. the normal event loop
GUIs have). `GameLoop()` in the engine now updates one step of the game and
returns.

Likewise, instead of explicitly calling `Render()`, I let the engine raise
events when things happen (monsters move, items are used, etc.) The UI can
hook into those and render the parts it needs to. So _…hand-waving…_ don't
worry about rendering.



    void ProcessGame(UserInput input)
    {
        HandleUserInput(input);
        UpdateGameState();
    }

Still pretty dumb. Let's delve into updating the game state.

### Monsters!

The game has a dungeon with a bunch of monsters and the player-controlled
hero. Something like:



    void UpdateGameState()
    {
        Hero.Move();

        foreach (Monster monster in Monsters)
        {
            monster.Move();
        }
    }

This works for games like checkers where everyone takes exactly one turn.
Here's where it gets a bit more complex. In my game, each entity moves at its
own speed so some may get more than one turn before others go. In addition,
the hero is basically the same thing as a monster except the player controls
him instead of AI doing it. Like this:



    void UpdateGameState()
    {
        // Entities has the hero in it too
        foreach (Entity entity in Entities)
        {
            entity.Move();
        }
    }

The tricky bit is because of speed, the UI may need to call `ProcessGame()`
multiple times before the hero actually needs user input. If the hero is
slower than monsters, some monsters will take multiple steps before the hero
takes one. This means there is no longer a 1-1 correspondence between
`ProcessGame()` calls and `HandleUserInput()`. In fact, the UI has to ask the
engine if it's time to provide user input. So `ProcessGame()` really become
"process the game in a loop until we need user input to continue":



    void ProcessGame()
    {
        while (true)
        {
            Entity entity = Entities[mCurrentEntity];

            if (entity.NeedsUserInput)
            {
                return;
            }
            else
            {
                entity.Move();

                mCurrentEntity = (mCurrentEntity + 1) % Entities.Count;
            }
        }
    }

Fairly simple. We loop through the entities, wrapping around and keep going
until we reach the hero who needs a move. But you'll notice we had to create a
field, `mCurrentEntity`, where we were just using a local `foreach` loop
before. That lets us pick up where we left off the last time we called the
function.

### It Gets Worse

That isn't so bad, but I also added processing for items (if you lay a burning
torch on the ground, it needs to process so it can eventually burn out):



    void ProcessGame()
    {
        while (true)
        {
            if (mInEntities)
            {
                Entity entity = Entities[mCurrentEntity];

                if (entity.NeedsUserInput)
                {
                    return;
                }
                else
                {
                    entity.Move();

                    mCurrentEntity++;

                    if (mCurrentEntity >= Entities.Count)
                    {
                        mCurrentEntity = 0;
                        mInEntities = false;
                    }
                }
            }
            else
            {
                Item item = Items[mCurrentItem];
                item.Move();

                mCurrentItem++;

                if (mCurrentItem >= Items.Count)
                {
                    mCurrentItem = 0;
                    mInEntities = true;
                }
            }
        }
    }

_Yeesh._ Now we've got another field to track the current item, and another
one just to track which of the two loops we're in. It's getting hairy and this
still isn't as complex as my actual game's process function, which includes
single moves which are multiple steps and some other shenanigans.

But, there's hope. Remember when I said, "lets up pick up where we left off
the last time we called it". Those member variables exist basically to get us
to jump back to the last place we were in the function. Sound familiar?

### Enter Iterators

Here's an iterator:



    IEnumerable<int> Fibonacci()
    {
        int a = 0;
        int b = 1;

        while(true)
        {
            yield return a;

            int swap = a;
            a = b;
            b = swap + b;
        }
    }

`yield return` lets us pick up where we left off, and we didn't have to create
any members to keep track of `a` and `b` because the `IEnumerable<int>`
created automatically by the compiler encapsulates that. A perfect fit! Let's
turn the game processing into the same thing:



    IEnumerable<bool> ProcessGame()
    {
        while (true)
        {
            foreach (Entity entity in Entities)
            {
                if (entity.NeedsUserInput)
                {
                    yield return true;
                }
                else
                {
                    entity.Move();
                }
            }

            foreach (Item item in Items)
            {
                item.Move();
            }
        }
    }

Much simpler, and we let the language take care of encapsulating the state
needed to return for us. Less code for us to monkey with.

### The Final Bit

The only annoying bit left now is that the UI actually needs to call
`ProcessGame()` _once_ and then iterate through the returned iterator
afterwards. To make things nicer, we can let the game handle that so that
`ProcessGame()` works exactly like it used to:



    void ProcessGame()
    {
        if (mIterator == null)
        {
            mIterator = CreateProcessIterator().GetEnumerator();
        }

        mIterator.MoveNext();
        bool dummy = mIterator.Current;
    }

    IEnumerable<bool> CreateProcessIterator()
    {
        while (true)
        {
            foreach (Entity entity in Entities)
            {
                if (entity.NeedsUserInput)
                {
                    yield return true;
                }
                else
                {
                    entity.Move();
                }
            }

            foreach (Item item in Items)
            {
                item.Move();
            }
        }
    }

You'll note that in the above example, we're using `IEnumerable<bool>`. The
`bool` there is pretty much arbitrary because the values of the `IEnumerable`
are irrelevant here. It's the [side-effect][50] of enumerating (i.e. updating
the game state) that matters. In the game, `Process()` actually does return
something so that the UI knows whether the game needs user input, or just to
pause for tick while showing an animation.

   [50]: http://en.wikipedia.org/wiki/Side_effect_(computer_science)

Discuss this at one of the sites below (or another of your choice):

[ ![][51]][52]

   [51]: http://cdn.stumble-upon.com/images/120x20_su_white.gif
   [52]: http://www.stumbleupon.com/submit?url=http://journal.stuffwithstuff.com%26title%3DThe%2BArticle%2BTitle

If you want to contact me directly, feel free to email at "name@site" where
"name" is "robert" and "site" is "stuffwithstuff.com".

(C) 2008-2009 Robert Nystrom

  *[GUI]: Graphical User Interface


