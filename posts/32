# [journal.

stuffwithstuff.com][1]

   [1]: http://journal.stuffwithstuff.com/

## me

  * [bob nystrom][2] is me
  * [bitbucket][3] has code
  * [github][4] has code
  * [flickr][5] has photos
  * [twitter][6] has status
  * [vimeo][7] has video

   [2]: http://www.stuffwithstuff.com/bob-nystrom.html
   [3]: http://bitbucket.org/munificent/
   [4]: http://github.com/munificent/
   [5]: http://www.flickr.com/photos/bobisbob/
   [6]: http://twitter.com/munificentbob
   [7]: http://vimeo.com/bobisbob

## archives

  * [2011][8]
  * [2010][9]
  * [2009][10]
  * [2008][11]

   [8]: http://journal.stuffwithstuff.com/2011/ (2011)
   [9]: http://journal.stuffwithstuff.com/2010/ (2010)
   [10]: http://journal.stuffwithstuff.com/2009/ (2009)
   [11]: http://journal.stuffwithstuff.com/2008/ (2008)

## tags

  * [blog][12] (2)
  * [c#][13] (13)
  * [code][14] (48)
  * [cpp][15] (7)
  * [design][16] (3)
  * [f#][17] (2)
  * [finch][18] (3)
  * [game-dev][19] (6)
  * [game-patterns][20] (3)
  * [go][21] (2)
  * [jasic][22] (1)
  * [java][23] (10)
  * [javascript][24] (3)
  * [language][25] (29)
  * [magpie][26] (19)
  * [optimization][27] (1)
  * [oscon][28] (1)
  * [parsing][29] (7)
  * [politics][30] (1)
  * [python][31] (2)
  * [roguelike][32] (2)
  * [ruby][33] (1)
  * [sml][34] (1)
  * [visualization][35] (1)

   [12]: http://journal.stuffwithstuff.com/category/blog/ (View all posts filed under blog)
   [13]: http://journal.stuffwithstuff.com/category/c/ (View all posts filed under c#)
   [14]: http://journal.stuffwithstuff.com/category/code/ (View all posts filed under code)
   [15]: http://journal.stuffwithstuff.com/category/cpp/ (View all posts filed under cpp)
   [16]: http://journal.stuffwithstuff.com/category/design/ (View all posts filed under design)
   [17]: http://journal.stuffwithstuff.com/category/f/ (View all posts filed under f#)
   [18]: http://journal.stuffwithstuff.com/category/finch/ (View all posts filed under finch)
   [19]: http://journal.stuffwithstuff.com/category/game-dev/ (View all posts filed under game-dev)
   [20]: http://journal.stuffwithstuff.com/category/game-patterns/ (View all posts filed under game-patterns)
   [21]: http://journal.stuffwithstuff.com/category/go/ (View all posts filed under go)
   [22]: http://journal.stuffwithstuff.com/category/jasic/ (View all posts filed under jasic)
   [23]: http://journal.stuffwithstuff.com/category/java/ (View all posts filed under java)
   [24]: http://journal.stuffwithstuff.com/category/javascript/ (View all posts filed under javascript)
   [25]: http://journal.stuffwithstuff.com/category/language/ (View all posts filed under language)
   [26]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts filed under magpie)
   [27]: http://journal.stuffwithstuff.com/category/optimization/ (View all posts filed under optimization)
   [28]: http://journal.stuffwithstuff.com/category/oscon/ (View all posts filed under oscon)
   [29]: http://journal.stuffwithstuff.com/category/parsing/ (View all posts filed under parsing)
   [30]: http://journal.stuffwithstuff.com/category/politics/ (View all posts filed under politics)
   [31]: http://journal.stuffwithstuff.com/category/python/ (View all posts filed under python)
   [32]: http://journal.stuffwithstuff.com/category/roguelike/ (View all posts filed under roguelike)
   [33]: http://journal.stuffwithstuff.com/category/ruby/ (View all posts filed under ruby)
   [34]: http://journal.stuffwithstuff.com/category/sml/ (View all posts filed under sml)
   [35]: http://journal.stuffwithstuff.com/category/visualization/ (View all posts filed under visualization)

## info

  * [famfamfam][36] provides icons
  * [RSS][37] syndicates me
  * [WordPress][38] powers me

   [36]: http://famfamfam.com/lab/icons/silk/
   [37]: feed:http://journal.stuffwithstuff.com/feed/
   [38]: http://wordpress.org/

## [void, null, Maybe and nothing][39]

   [39]: http://journal.stuffwithstuff.com/2010/08/23/void-null-maybe-and-nothing/ (void, null, Maybe and nothing)

[code][40] | [java][41] | [language][42] | [magpie][43] [2010][44] / [08][45]
/ [23][46]

   [40]: http://journal.stuffwithstuff.com/category/code/ (View all posts in code)
   [41]: http://journal.stuffwithstuff.com/category/java/ (View all posts in java)
   [42]: http://journal.stuffwithstuff.com/category/language/ (View all posts in language)
   [43]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts in magpie)
   [44]: http://journal.stuffwithstuff.com/2010/ (year)
   [45]: http://journal.stuffwithstuff.com/2010/08/ (month)
   [46]: http://journal.stuffwithstuff.com/2010/08/23/

I'm hard at work on a proof-of-concept for the new [Magpie][47]. While I've
got some more work to do before I can start getting into the really
interesting parts of the language, I have one piece working now that I think
is kind of cool, and that's… _nothing_.

   [47]: http://bitbucket.org/munificent/magpie

### Absence and Failure

Every programming language has to provide a mechanism for two kinds of
absences: when a function _always_ returns nothing, and when it _sometimes_
returns nothing.

C has the `void` type for the former. A function that just performs some side-
effect like printing to the screen is declared to return `void`, like:



    void sayHi() {
        printf("hi!");
    }


And the compiler will check to make sure you don't do something dumb like:



    int a = sayHi();


Failing to return _sometimes_ is a lot trickier. Consider a function that
takes a path and returns a handle to a file. If there is no file at the given
path, there's no `File` it can return so it needs to fail somehow. The way
most OOP languages like Java and C# handle this is by returning `null`:



    File openFile(String path) {
        if (isValid(path)) {
            return new File(path);
        } else {
            return null;
        }
    }


For any reference type (like `File`), a variable can have a valid value, or it
can be `null`. In other words, `null` is this magical value that exists as a
member of every type. "Hey there" is a string, and `null` is a string. `new
File("foo/bar.txt")` is a file, and `null` is a file.

### Meta-failure

The real problem with this is that now you've lost the ability to declare that
a function _won't_ fail. _Any_ function that returns a reference type can in
principle return `null` even though most never do. To be safe, you end up
having to check for it everywhere. Even then, things slip through causing tons
of real-world bugs.

Tony Hoare, the guy who gets the dubious honor of inventing `null` calls this
his ["billion dollar mistake"][48]. I don't have a billion dollars, so I don't
want to make this mistake in Magpie.

   [48]: http://lambda-the-ultimate.org/node/3186

### Maybe Another Solution

Fortunately, other languages don't have this problem. The ML family of
languages, including Haskell and F#, _don't_ allow `null` as a value for every
type. If you have a variable of type Foo, you can sleep soundly at night
knowing it will only and always contain a valid value of type Foo.

But now we're back to our first problem. How would we implement `openFile()`
then? It can't return `File` because it might not always file the file. ML
languages handle this with a special type called `[Maybe][49]` (Haskell) or
`[Option][50]` (ML and everything else).

   [49]: http://www.haskell.org/onlinereport/maybe.html
   [50]: http://www.standardml.org/Basis/option.html

This is a special wrapper that may optionally contain a value of some type
(hence the name). Our `openFile()`, instead of returning `File`, will return
`File option`.

Crisis averted. The only trick is that if you're the code calling `openFile()`
you've got this option thing now instead of a `File`. How do you get the file
back out? ML languages use something called "pattern matching", which is
basically a pimped out `switch` statement. I won't go into it here, but it's
swell.

### Wasn't I Talking about _My_ Language?

Ah, yes. Magpie. Where was I? OK, so which path does Magpie follow? Well…
neither, actually. So Java and C# use `void` for functions that never return a
value and `null` for functions that might sometimes fail. ML-family languages
use something called "Unit" instead of `void` and `Option`/`Maybe` for
occasional failure.

Magpie has one concept that it uses for both: `nothing`. In Magpie, there is a
single value called `nothing` that represents the absence of a value. If you
have a function that just has side-effects, that's what it returns implicitly.
For example, this function returns `nothing`:



    var sayHi(->)
        print("hi")
    end


The `(->)` is the type signature. In this case, it takes no arguments (there's
nothing to the left of the arrow) and it returns nothing (there's nothing to
the right). If we wanted to be more explicit, we could say:



    var sayHi(-> Nothing)
        print("hi")
    end


Note how "Nothing" is capitalized. `nothing` is the value, `Nothing` is its
type. There is only one value of type `Nothing` and its name is `nothing`.

That much is easy. What about `openFile()`? If I had a billion dollars to
blow, it would be:



    var openFile(path String -> File)
        if path valid? then File new(path)
        else nothing
    end


and we'd let `nothing` silently masquerade as a file. But `nothing` isn't a
file, it's a `Nothing`. So the above program won't type-check. What we need is
a way to say that `openFile()` can return a String _or nothing_.

### Or Some Other Solution

I'm all about the obvious solution, so I just took that literally. So Magpie
has _or types_. (I'm guessing there may be other names for them in the
literature. I know I didn't invent them.) A correct version of `openFile()`
looks like:



    var openFile(path String -> File | Nothing)
        if path valid? then File new(path)
        else nothing
    end


My hope is that that's pretty clear and easy to understand: `openFile` takes a
string and returns a file or nothing. It reads just like you'd say it.

### But I Don't Want Nothing!

There's one last little problem we're left with though. If we're the ones
_calling_ `openFile()` now, what do we do with what we got back? If we try
this:



    var myFile = openFile("path/to/file.txt")
    myFile read


We'll get a compile error on the second line. You can't call `read` on
`nothing` and `myFile` might be just that. To address that, Magpie has a
little thing called `let`. It's a lightweight version of full pattern matching
(which the old C# Magpie has, and the new Java will at some point) to make
this exact case easy to work with. It looks like this:



    let myFile = openFile("path/to/file.txt") then
        myFile read
    else
        print("Couldn't open file!")
    end


A `let` combines conditional logic like `if` with defining a variable. First,
it evaluates the right-hand expression (`openFile...` in this case). If, and
only if, that expression doesn't return `nothing`, it will bind the result to
a new variable (`myFile` here), whose type is the type of the expression
without the "| Nothing" clause. Then it will evaluate the expression after
`then`.

The nice part is that `myFile` will only exist within the body of the `then`
clause, and only if it isn't `nothing`. There's no way to try to call `read`
on something that isn't a valid `File`. We're totally type-safe while still
keeping things pretty simple and easy to use.

Discuss this at one of the sites below (or another of your choice):

[ ![][51]][52]

   [51]: http://cdn.stumble-upon.com/images/120x20_su_white.gif
   [52]: http://www.stumbleupon.com/submit?url=http://journal.stuffwithstuff.com%26title%3DThe%2BArticle%2BTitle

If you want to contact me directly, feel free to email at "name@site" where
"name" is "robert" and "site" is "stuffwithstuff.com".

(C) 2008-2009 Robert Nystrom


