# [journal.

stuffwithstuff.com][1]

   [1]: http://journal.stuffwithstuff.com/

## me

  * [bob nystrom][2] is me
  * [bitbucket][3] has code
  * [github][4] has code
  * [flickr][5] has photos
  * [twitter][6] has status
  * [vimeo][7] has video

   [2]: http://www.stuffwithstuff.com/bob-nystrom.html
   [3]: http://bitbucket.org/munificent/
   [4]: http://github.com/munificent/
   [5]: http://www.flickr.com/photos/bobisbob/
   [6]: http://twitter.com/munificentbob
   [7]: http://vimeo.com/bobisbob

## archives

  * [2011][8]
  * [2010][9]
  * [2009][10]
  * [2008][11]

   [8]: http://journal.stuffwithstuff.com/2011/ (2011)
   [9]: http://journal.stuffwithstuff.com/2010/ (2010)
   [10]: http://journal.stuffwithstuff.com/2009/ (2009)
   [11]: http://journal.stuffwithstuff.com/2008/ (2008)

## tags

  * [blog][12] (2)
  * [c#][13] (13)
  * [code][14] (48)
  * [cpp][15] (7)
  * [design][16] (3)
  * [f#][17] (2)
  * [finch][18] (3)
  * [game-dev][19] (6)
  * [game-patterns][20] (3)
  * [go][21] (2)
  * [jasic][22] (1)
  * [java][23] (10)
  * [javascript][24] (3)
  * [language][25] (29)
  * [magpie][26] (19)
  * [optimization][27] (1)
  * [oscon][28] (1)
  * [parsing][29] (7)
  * [politics][30] (1)
  * [python][31] (2)
  * [roguelike][32] (2)
  * [ruby][33] (1)
  * [sml][34] (1)
  * [visualization][35] (1)

   [12]: http://journal.stuffwithstuff.com/category/blog/ (View all posts filed under blog)
   [13]: http://journal.stuffwithstuff.com/category/c/ (View all posts filed under c#)
   [14]: http://journal.stuffwithstuff.com/category/code/ (View all posts filed under code)
   [15]: http://journal.stuffwithstuff.com/category/cpp/ (View all posts filed under cpp)
   [16]: http://journal.stuffwithstuff.com/category/design/ (View all posts filed under design)
   [17]: http://journal.stuffwithstuff.com/category/f/ (View all posts filed under f#)
   [18]: http://journal.stuffwithstuff.com/category/finch/ (View all posts filed under finch)
   [19]: http://journal.stuffwithstuff.com/category/game-dev/ (View all posts filed under game-dev)
   [20]: http://journal.stuffwithstuff.com/category/game-patterns/ (View all posts filed under game-patterns)
   [21]: http://journal.stuffwithstuff.com/category/go/ (View all posts filed under go)
   [22]: http://journal.stuffwithstuff.com/category/jasic/ (View all posts filed under jasic)
   [23]: http://journal.stuffwithstuff.com/category/java/ (View all posts filed under java)
   [24]: http://journal.stuffwithstuff.com/category/javascript/ (View all posts filed under javascript)
   [25]: http://journal.stuffwithstuff.com/category/language/ (View all posts filed under language)
   [26]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts filed under magpie)
   [27]: http://journal.stuffwithstuff.com/category/optimization/ (View all posts filed under optimization)
   [28]: http://journal.stuffwithstuff.com/category/oscon/ (View all posts filed under oscon)
   [29]: http://journal.stuffwithstuff.com/category/parsing/ (View all posts filed under parsing)
   [30]: http://journal.stuffwithstuff.com/category/politics/ (View all posts filed under politics)
   [31]: http://journal.stuffwithstuff.com/category/python/ (View all posts filed under python)
   [32]: http://journal.stuffwithstuff.com/category/roguelike/ (View all posts filed under roguelike)
   [33]: http://journal.stuffwithstuff.com/category/ruby/ (View all posts filed under ruby)
   [34]: http://journal.stuffwithstuff.com/category/sml/ (View all posts filed under sml)
   [35]: http://journal.stuffwithstuff.com/category/visualization/ (View all posts filed under visualization)

## info

  * [famfamfam][36] provides icons
  * [RSS][37] syndicates me
  * [WordPress][38] powers me

   [36]: http://famfamfam.com/lab/icons/silk/
   [37]: feed:http://journal.stuffwithstuff.com/feed/
   [38]: http://wordpress.org/

## [ML-style Pattern Matching in C#][39]

   [39]: http://journal.stuffwithstuff.com/2009/05/13/ml-style-pattern-matching-in-c/ (ML-style Pattern Matching in C#)

[c#][40] | [code][41] | [f#][42] | [language][43] [2009][44] / [05][45] /
[13][46]

   [40]: http://journal.stuffwithstuff.com/category/c/ (View all posts in c#)
   [41]: http://journal.stuffwithstuff.com/category/code/ (View all posts in code)
   [42]: http://journal.stuffwithstuff.com/category/f/ (View all posts in f#)
   [43]: http://journal.stuffwithstuff.com/category/language/ (View all posts in language)
   [44]: http://journal.stuffwithstuff.com/2009/ (year)
   [45]: http://journal.stuffwithstuff.com/2009/05/ (month)
   [46]: http://journal.stuffwithstuff.com/2009/05/13/

There's nothing like travelling abroad to make you see your home country with
new eyes. While your first fascination with everything new and different in
the foreign land may enventually be replaced by homesickness, you always want
to bring back a souvenir, a little bit of the best of where you've been.

C# is my home country these days, but I've been vacationing in F#. There's a
lot there that's absolutely brilliant, like [currying][47] and [partial
application][48], [workflows][49], and [option types][50] (no more
[NullReferenceExceptions][51]!). But one of the first things I fell in love
with in the language was pattern matching. Pattern matching in F# (and its
ancestors ML and OCaml) is something like `switch/case` on steroids. Here's a
simple example of a `switch/case` in C#:


       [47]: http://en.wikipedia.org/wiki/Currying
   [48]: http://ejohn.org/blog/partial-functions-in-javascript/
   [49]: http://www.infoq.com/articles/pickering-fsharp-workflow
   [50]: http://www.markhneedham.com/blog/2009/01/02/f-option-types/
   [51]: http://qconlondon.com/london-2009/presentation/Null+References:+The+Billion+Dollar+Mistake

    int i = 2;
    switch (i)
    {
        case 0:  Print("zero");
        case 1:  Print("one");
        case 2:  Print("two");
        default: Print("some other value");
    }


Here's what the same logic would look like in F#:



    let i = 2
    match i with
    | 0 -> Print("zero")
    | 1 -> Print("one")
    | 2 -> Print("two")
    | _ -> Print("some other value")


You can probably infer what's going on. Pretty similar to our familiar
`switch/case`. It checks each value and executes the clause on the right the
first time it finds a match. The `_` bit on the last line is equivalent to
`default` in a `switch/case`: it always gets matched if we get that far. Basic
stuff, but pattern matching can do so much more. Before I can explain _that_,
though, we'll need to take a little side trip to see another F# feature:
[discriminated unions][52].

   [52]: http://en.wikipedia.org/wiki/Variant_record

#### Discriminated Unions

Where C# has enums, F# has discriminated unions. The main difference between
the two is that each value in the union can have additional data fields.
Imagine you want to enumerate the different kinds of [image macros][53]:


       [53]: http://en.wikipedia.org/wiki/Image_macro

    enum ImageMacro
    {
        Lolcat,
        Lolrus,
        ORlyOwl
    }


Pretty basic. Now if it's a [lolcat][54], we also want to note the text of the
caption, and if it's a [lolrus][55], we want to note how many buckets it has.
In C#, we'd have to ditch the enum and resort to a class hierarchy:


       [54]: http://en.wikipedia.org/wiki/Lolcat
   [55]: http://icanhascheezburger.com/2007/01/14/i-has-a-bucket/

    abstract class ImageMacro { }

    class Lolcat : ImageMacro
    {
        public string Caption;
        public Lolcat(string caption) { Caption = caption; }
    }

    class Lolrus : ImageMacro
    {
        public int Buckets;
        public Lolrus(int buckets) { Buckets = buckets; }
    }

    class ORlyOwl : ImageMacro { }


Classic OOP design, and it gets the job done. In F#, you can simply add fields
to a discriminated union and accomplish the exact same thing:



    type ImageMacro =
        | Lolcat    of string
        | Lolrus    of int
        | ORlyOwl


The "of string" says that when you make a Lolcat ImageMacro (and _only_ a
Lolcat) that you must also provide a caption. Likewise, the "of int" says that
a Lolrus needs a number of buckets.

#### Pattern Matching Discriminated Unions

These two features, pattern matching and discriminated unions, go together in
F# like gondolas and striped shirts. Each is much less awesome without the
other. Now let's get back to pattern matching and see something it can do that
a `switch/case` definitely can't. Given our above ImageMacro type, let's say
we want to print it out:



    let image = Lolcat("I made you a cookie")
    match image with
    | Lolcat(caption) -> Print("Lolcat says '" + caption + "'")
    | Lolrus(buckets) -> Print("Lolrus has " + buckets + " buckets")
    | ORlyOwn         -> Print("O RLY?")


Now _that's_ pretty nice. Not only does it switch on what kind of image macro
it is, it also pulls out the data associated with each one ("destructures" in
the local parlance). This would definitely be nice to have in C#.

### A Little Souvenir: Pattern.Match

So can we bring discriminated union pattern matching back to C#? Since C#
doesn't have discriminated unions, we'll have to make it work with the little
inheritance tree up there. Here's what I got:



    ImageMacro image = new Lolcat("I made you a cookie");
    Pattern.Match(image).
        Case<Lolcat, string> (c  => Print("Lolcat says '" + c + "'")).
        Case<Lolrus, int>    (b  => Print("I has " + b + " buckets")).
        Case<ORlyOwl>        (() => Print("O RLY?"));


A little strange, but not _too_ bad. Looks kind of like a `switch/case` but
switches based on type. For `Lolcat` and `Lolrus`, we pull out the caption and
number of buckets. How does this work? Let's build it from the bottom up.

#### Case()

A single case in our pattern matcher needs to specify three things: the type
being selected (Lolcat, Lolrus, etc.), the field(s) to pull out (if any), and
the action to perform when the case is successfully matched. Let's start with
the simplest possible system: one that can only match a single value based on
type, with no fields. Here's the basic class:



    public class Matcher<T>
    {
        public Matcher(T value) { mValue = value; }

        public void Case<TCase>(Action action)
        {
            if (mValue is TCase) action();
        }

        private T mValue;
    }


The action being passed in is a delegate, and we construct it using C# 3.5's
handy lambda notation. For the ORlyOwl, it's:



    () => Print("O RLY?")


Aside from being a nice clean notation, the other nice thing about lambdas
(and anonymous delegates) is that they can access variables defined in the
outside scope. This lets our `Case` clauses do everything a regular `case` can
do in a vanilla `switch/case`.

#### Chaining Cases Using a Fluent Interface

What we have so far is simple, but it only lets us select a single case. To be
able to chain multiple cases together, we're going to use something the hip
kids are calling a "fluent interface". The basic idea is to make methods
return `this` so that you can call multiple methods on the same object by
`chaining.Them().Like().This()`:



    public Matcher<T> Case<TCase>(Action action)
    {
        if (mValue is TCase) action();
        return this;
    }


#### Preventing Multiple Matches

There's a problem here. A pattern should only match the _first_ successful
case. If we just allow arbitrary chaining, it would be possible to have
multiple matches. Here's a solution:



    public virtual Matcher<T> Case<TCase>(Action action)
    {
        if (mValue is TCase)
        {
            action();
            return new NullMatcher<T>();
        }
        return this;
    }


Now when we have a successful match, instead of continuing the fluent
interface and returning `this`, we return a `NullMatcher<T>` As you can
probably guess, that class has the same methods as `Matcher<T>`, but never
actually matches:



    public class NullMatcher<T> : Matcher<T>
    {
        public override Matcher<T> Case<TCase>(Action action)
        {
            return this;
        }
    }


#### Extracting Fields

So far, we're up to being able to do this:



    Pattern.Match(image).
        Case<Lolcat>    (caption => Print("Lolcat says '?'")).
        Case<Lolrus>    (buckets => Print("Lolrus has ? buckets")).
        Case<ORlyOwl>   (()      => Print("O RLY?"));


The last remaining step is to pull out the `caption` and `buckets` from the
`Lolcat` and `Lolrus` types. We'll do this by overloading `Case()`:



    public virtual Matcher<T> Case<TCase, TArg>(Action <TArg> action)
    {
        IMatchable<TArg> matchable = mValue as IMatchable<TArg>;

        if ((matchable != null) && (mValue is TCase))
        {
            action(matchable.GetArg());
            return new NullMatcher<T>();
        }
        else
        {
            return this;
        }
    }


What this does is both check the type and see if it implements
`IMatchable<T>`. This little interface just lets a class expose a field for
pattern matching. (We could also do this using reflection. That would free us
up from having explicitly implement pattern matching support in classes, but
would also incur a performance penalty and bind the pattern matching to the
internals of the matched classes.) Here's the interface and it's
implementation in our macro classes:



    interface IMatchable<TArg>
    {
        TArg GetArg();
    }

    class Lolcat : ImageMacro, IMatchable<string>
    {
        public string Caption;
        public Lolcat(string caption) { Caption = caption; }

        string IMatchable<string>.GetArg() { return Caption; }
    }

    class Lolrus : ImageMacro, IMatchable<int>
    {
        public int NumBuckets;
        public Lolrus(int numBuckets) { NumBuckets = numBuckets; }

        int IMatchable<int>.GetArg() { return NumBuckets; }
    }


I'm using explicit interface implementation here, because users only really
care about using `GetArg()` when they're doing pattern matching. Otherwise,
there's no reason to make it a visible part of the class's interface.

#### Pattern

We've built back almost up the to the top. The last little bit left is the
simplest:



    Pattern.Match(image)


`Pattern` is simply a static class with one method `Match()`:



    class Pattern
    {
        public static Matcher<T> Match<T>(T value)
        {
            return new Matcher<T>(value);
        }
    }


The Pattern class exists simply because C# requires all functions to be in a
class. However, constructing Matchers through `Match<T>` does have one nice
side-effect: it lets the compiler infer the type parameter so you don't have
to explicitly write it out like you would when calling a constructor.

With this little bit in place, we've reached our goal of being able to get
something like matching discriminated unions working in C#:



    Pattern.Match(image).
        Case<Lolcat, string> (c  => Print("Lolcat says '" + c + "'")).
        Case<Lolrus, int>    (b  => Print("I has " + b + " buckets")).
        Case<ORlyOwl>           (() => Print("O RLY?"));


### But Wait, That's Not All!

This is only the beginning of what we can do with our little matching class.
Here are a few other things the full code lets you do:

#### Extracting Multiple Fields

In the example above, we only pull a single field out of a given case. F#
supports multiple fields as well, as does the Matcher class (up to four):



    Case<Loldog, string, int> ((caption, dogs) =>
        Print("'" + caption + "', says " + dogs + " hotdogs")).


#### Default Case

It's also useful to have a `default`-like case that will always succeed if
reached:



    Pattern.Match(image).
        Case<Lolrus, int> (b  => Print("I has " + buckets + " buckets")).
        Default                 (() => Print("Default"));


#### Equality Matching

Another way to match values is if they are equal. We can do this generically
since `Equals()` is part of the .NET framework.



    Pattern.Match("a string").
        Case("not",      () => Print("should not match")).
        Case("a string", () => Print("should match"));


The example here uses strings, but this works with any type as long as it
implements `Equals()` correctly.

#### Matching on Any Predicate

As you can see, there are a bunch of different ways users may want to match
data, and it's futile to try to bake all of them into the class. The most
obvious solution then is to simply let users pass in an arbitrary predicate (a
predicate is a function that returns a bool) and have the match succeed based
on that:



    Pattern.Match(123).
        Case(value => value < 100, () => Print("less than 100")).
        Case(value => value > 100, () => Print("greater than 100"));


You'll note that in the final code below, all of the other matching types are
built on top of this.

#### Returning a Value

F#, unlike C#, treats everything as an expression, even flow control
statements like `if/then` and `match`. This means a match can return a result,
where in C# you'd have to do an assignment:



    // C#
    bool isTwo;
    switch (2)
    {
        case 2:  isTwo = true;
        default: isTwo = false;
    }

    // F#:
    let isTwo = match 2 with
                | 2 -> true
                | _ -> false


Our pattern matching class can do this too, even within C#:



    bool isTwo = Pattern.Match<int, bool>(2).
                     Case(2,  true).
                     Default( false);


### Conclusion

They say you never know your home until you travel abroad. I've been enjoying
F# a lot, but C# still feels more comfortable to me. However, it's always
useful to see how other languages solve problems, and see what new techniques
can be brought home with you. While our pattern matching class isn't quite as
clean in C# as it is in F#, I think it's a useful tool in its own right.

If you'd like to play with it, [I've put it up on bitbucket][56]. Have fun!

   [56]: http://bitbucket.org/munificent/pattern_matching/

Discuss this at one of the sites below (or another of your choice):

[ ![][57]][58]

   [57]: http://cdn.stumble-upon.com/images/120x20_su_white.gif
   [58]: http://www.stumbleupon.com/submit?url=http://journal.stuffwithstuff.com%26title%3DThe%2BArticle%2BTitle

If you want to contact me directly, feel free to email at "name@site" where
"name" is "robert" and "site" is "stuffwithstuff.com".

(C) 2008-2009 Robert Nystrom


