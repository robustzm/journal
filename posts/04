# [journal.

stuffwithstuff.com][1]

   [1]: http://journal.stuffwithstuff.com/

## me

  * [bob nystrom][2] is me
  * [bitbucket][3] has code
  * [github][4] has code
  * [flickr][5] has photos
  * [twitter][6] has status
  * [vimeo][7] has video

   [2]: http://www.stuffwithstuff.com/bob-nystrom.html
   [3]: http://bitbucket.org/munificent/
   [4]: http://github.com/munificent/
   [5]: http://www.flickr.com/photos/bobisbob/
   [6]: http://twitter.com/munificentbob
   [7]: http://vimeo.com/bobisbob

## archives

  * [2011][8]
  * [2010][9]
  * [2009][10]
  * [2008][11]

   [8]: http://journal.stuffwithstuff.com/2011/ (2011)
   [9]: http://journal.stuffwithstuff.com/2010/ (2010)
   [10]: http://journal.stuffwithstuff.com/2009/ (2009)
   [11]: http://journal.stuffwithstuff.com/2008/ (2008)

## tags

  * [blog][12] (2)
  * [c#][13] (13)
  * [code][14] (48)
  * [cpp][15] (7)
  * [design][16] (3)
  * [f#][17] (2)
  * [finch][18] (3)
  * [game-dev][19] (6)
  * [game-patterns][20] (3)
  * [go][21] (2)
  * [jasic][22] (1)
  * [java][23] (10)
  * [javascript][24] (3)
  * [language][25] (29)
  * [magpie][26] (19)
  * [optimization][27] (1)
  * [oscon][28] (1)
  * [parsing][29] (7)
  * [politics][30] (1)
  * [python][31] (2)
  * [roguelike][32] (2)
  * [ruby][33] (1)
  * [sml][34] (1)
  * [visualization][35] (1)

   [12]: http://journal.stuffwithstuff.com/category/blog/ (View all posts filed under blog)
   [13]: http://journal.stuffwithstuff.com/category/c/ (View all posts filed under c#)
   [14]: http://journal.stuffwithstuff.com/category/code/ (View all posts filed under code)
   [15]: http://journal.stuffwithstuff.com/category/cpp/ (View all posts filed under cpp)
   [16]: http://journal.stuffwithstuff.com/category/design/ (View all posts filed under design)
   [17]: http://journal.stuffwithstuff.com/category/f/ (View all posts filed under f#)
   [18]: http://journal.stuffwithstuff.com/category/finch/ (View all posts filed under finch)
   [19]: http://journal.stuffwithstuff.com/category/game-dev/ (View all posts filed under game-dev)
   [20]: http://journal.stuffwithstuff.com/category/game-patterns/ (View all posts filed under game-patterns)
   [21]: http://journal.stuffwithstuff.com/category/go/ (View all posts filed under go)
   [22]: http://journal.stuffwithstuff.com/category/jasic/ (View all posts filed under jasic)
   [23]: http://journal.stuffwithstuff.com/category/java/ (View all posts filed under java)
   [24]: http://journal.stuffwithstuff.com/category/javascript/ (View all posts filed under javascript)
   [25]: http://journal.stuffwithstuff.com/category/language/ (View all posts filed under language)
   [26]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts filed under magpie)
   [27]: http://journal.stuffwithstuff.com/category/optimization/ (View all posts filed under optimization)
   [28]: http://journal.stuffwithstuff.com/category/oscon/ (View all posts filed under oscon)
   [29]: http://journal.stuffwithstuff.com/category/parsing/ (View all posts filed under parsing)
   [30]: http://journal.stuffwithstuff.com/category/politics/ (View all posts filed under politics)
   [31]: http://journal.stuffwithstuff.com/category/python/ (View all posts filed under python)
   [32]: http://journal.stuffwithstuff.com/category/roguelike/ (View all posts filed under roguelike)
   [33]: http://journal.stuffwithstuff.com/category/ruby/ (View all posts filed under ruby)
   [34]: http://journal.stuffwithstuff.com/category/sml/ (View all posts filed under sml)
   [35]: http://journal.stuffwithstuff.com/category/visualization/ (View all posts filed under visualization)

## info

  * [famfamfam][36] provides icons
  * [RSS][37] syndicates me
  * [WordPress][38] powers me

   [36]: http://famfamfam.com/lab/icons/silk/
   [37]: feed:http://journal.stuffwithstuff.com/feed/
   [38]: http://wordpress.org/

## [What's the Opposite of "nullable"?][39]

   [39]: http://journal.stuffwithstuff.com/2008/04/08/whats-the-opposite-of-nullable/ (What&#8217;s the Opposite of &#8220;nullable&#8221;?)

[c#][40] | [code][41] [2008][42] / [04][43] / [08][44]

   [40]: http://journal.stuffwithstuff.com/category/c/ (View all posts in c#)
   [41]: http://journal.stuffwithstuff.com/category/code/ (View all posts in code)
   [42]: http://journal.stuffwithstuff.com/2008/ (year)
   [43]: http://journal.stuffwithstuff.com/2008/04/ (month)
   [44]: http://journal.stuffwithstuff.com/2008/04/08/

I hate [duplicate code][45]. [Hate it][46] [hate it][47] [hate it][48]. At the
same time, I _do_ like having my code check its arguments.

   [45]: http://en.wikipedia.org/wiki/DRY
   [46]: http://c2.com/cgi/wiki?DontRepeatYourself
   [47]: http://www.codinghorror.com/blog/archives/000805.html
   [48]: http://www.thefrontside.net/blog/repeat_yourself

After a while, I noticed that half of the functions I wrote looked like this



    void SomeMethod(Foo foo)
    {
        if (foo == null) throw new ArgumentNullException("foo");

        // ...
    }

That's good code in the sense that it bails on `null`, but it's got a couple
of things I don't like:

First, I have to keep copying and pasting that exception line in every method.
I know, it's just one line, but it started to annoy me.

Worse is that to a _caller_ of the function, there's no way to tell that
`SomeMethod()` doesn't allow a `null` value for `foo` without looking at the
method body (which may not be available to an API user).

The `[Nullable<T>][49]` type in the [BCL][50] (which is automatically aliased
to it's [more familiar `?`][51], as in "`int?`") had me wondering. Can I make
the opposite? A "not nullable?"

   [49]: http://msdn2.microsoft.com/en-us/library/b3h38hb0.aspx
   [50]: http://msdn2.microsoft.com/en-us/netframework/aa569603.aspx
   [51]: http://blogs.msdn.com/ericgu/archive/2004/05/27/143221.aspx

### NotNull<T>

Let's build it a bit at a time. The core not-very-clever idea is just a class
that wraps a reference. When you construct it, it throws our familiar
`ArgumentNullException` if the reference is `null`:



    public class NotNull<T>
    {
        public T Value
        {
            get { return mValue; }
        }

        public NotNull(T maybeNull)
        {
            if (maybeNull == null) throw new ArgumentNullException("maybeNull");

            mValue = maybeNull;
        }

        private T mValue;
    }

Definitely not rocket science. Now you can define methods like this:



    void SomeMethod(NotNull<Foo> foo)
    {
    }

By the time you get to your method body, you can be sure that `foo` is not
`null`. Unfortunately, your call sites just got uglier:



    SomeMethod(new NotNull(myFoo));

A conversion operator will fix that:



    // in NotNull<T>
    public static implicit operator NotNull<T>(T maybeNull)
    {
        return new NotNull<T>(maybeNull);
    }

Now the call sites are unchanged:



    SomeMethod(mFoo);

and when you make the call, it will automatically call the conversion, which
will in turn bail if `myFoo` is `null`. We can make things a little easier by
providing a conversion the other way too:



    public static implicit operator T(NotNull<T> notNull)
    {
        return notNull.Value;
    }

Now you can do this:



    void SomeMethod(NotNull<Foo> foo)
    {
        // will automatically convert on assign :)
        Foo someFoo = foo;

        // but not on member access :(
        // can't do foo.SomeFooProperty, have to do:
        foo.Value.SomeFooProperty;
    }

Not too shabby. The bonus, and the real reason I like this is that you've now
**decorated the function signature itself with its requirements**. Any caller
of `SomeMethod()` will now see in Intellisense that it requires a
`NotNull<Foo>`. We've moved an _imperative_ exception check to a
_[declarative][52] property_ of the argument itself.

   [52]: http://en.wikipedia.org/wiki/Declarative_programming

### Caveats

I'd like to say this is a perfect solution, but alas it's not. There's at
least one caveat to be aware of. This won't work with interface types. That's
because value types can implement interfaces too, and you can't compare a
value type to `null`. If you can figure out a way around this, holler.

**Edit:** as Brad points out below, this does work with interfacesâ€¦ sort of. The limitation is that implicit conversion operators don't work with them. The actual wrapping and `null` checks are fine. It's just that to use it with an interface, you have to do:


    SomeMethod(new NotNull(myInterfaceFoo));

which is kind of lame. But aside from that, you can use interfaces with this.
Thanks, B-Rad!

### The Whole Shebang

Oh, and here's a prettier version with comments and stuff. Don't say I never
gave you nothing:



    /// <summary>
    /// <para>
    /// Wrapper around a reference that ensures the reference is not <c>null</c>.
    /// Provides implicit cast operators to automatically wrap and unwrap
    /// values.
    /// </para>
    /// <para>
    /// NotNull{T} can be used as an argument to a method to ensure that
    /// no <c>null</c> values are passed to the method in place of manually
    /// throwing an <see cref="ArgumentNullException"/>. It has an added
    /// benefit over that because using it as an argument type clearly
    /// communicates to the caller the expectation of the method.
    /// </para>
    /// </summary>
    /// <typeparam name="T">Type being wrapped.</typeparam>
    public class NotNull<T>
    {
        /// <summary>
        /// Automatically unwraps the non-<c>null</c> object being wrapped
        /// by this NotNull{T}.
        /// </summary>
        /// <param name="notNull">The wrapper.</param>
        /// <returns>The raw object being wrapped.</returns>
        public static implicit operator T(NotNull<T> notNull)
        {
            return notNull.Value;
        }

        /// <summary>
        /// Automatically wraps an object in a NotNull{T}. Will throw
        /// an <see cref="ArgumentNullException"/> if the value being
        /// wrapped is <c>null</c>.
        /// </summary>
        /// <param name="maybeNull">The raw reference to wrap.</param>
        /// <returns>A new NotNull{T} that wraps the value, provided the
        /// value is not <c>null</c>.</returns>
        /// <exception cref="ArgumentNullException">If <c>maybeNull</c> is <c>null</c>.</exception>
        public static implicit operator NotNull<T>(T maybeNull)
        {
            return new NotNull<T>(maybeNull);
        }

        /// <summary>
        /// Gets and sets the non-null reference being wrapped by this
        /// NotNull{T}.
        /// </summary>
        /// <exception cref="ArgumentNullException">If <c>value</c> is <c>null</c>.</exception>
        public T Value
        {
            get { return mValue; }
            set
            {
                if (value == null) throw new ArgumentNullException("value");
                mValue = value;
            }
        }

        /// <summary>
        /// Creates a new wrapper around the given reference.
        /// </summary>
        /// <remarks>Explicitly calling the constructor is rarely needed. Usually the
        /// implicit cast is simpler.</remarks>
        /// <param name="maybeNull">The reference to wrap.</param>
        /// <exception cref="ArgumentNullException">If <c>maybeNull</c> is <c>null</c>.</exception>
        public NotNull(T maybeNull)
        {
            if (maybeNull == null) throw new ArgumentNullException("maybeNull");

            mValue = maybeNull;
        }

        private T mValue;
    }

and a unit test:



    [TestFixture]
    public class NotNullFixture
    {
        [Test]
        public void TestConstructor()
        {
            Foo foo = new Foo();
            NotNull<Foo> notNull = new NotNull<Foo>(foo);
        }

        [Test]
        [ExpectedException(typeof(ArgumentNullException))]
        public void TestConstructorThrowsOnNull()
        {
            Foo foo = null;
            NotNull<Foo> notNull = new NotNull<Foo>(foo);
        }

        [Test]
        public void TestGetValue()
        {
            Foo foo = new Foo();
            NotNull<Foo> notNull = new NotNull<Foo>(foo);

            Assert.AreEqual(foo, notNull.Value);
        }

        [Test]
        public void TestImplicitWrap()
        {
            Foo foo = new Foo();
            NotNull<Foo> notNull = foo;

            Assert.AreEqual(foo, notNull.Value);
        }

        [Test]
        public void TestImplicitUnwrap()
        {
            Foo foo = new Foo();
            NotNull<Foo> notNull = new NotNull<Foo>(foo);

            Foo unwrap = notNull;

            Assert.AreEqual(foo, unwrap);
        }

        public class Foo { }
    }

Discuss this at one of the sites below (or another of your choice):

[ ![][53]][54]

   [53]: http://cdn.stumble-upon.com/images/120x20_su_white.gif
   [54]: http://www.stumbleupon.com/submit?url=http://journal.stuffwithstuff.com%26title%3DThe%2BArticle%2BTitle

If you want to contact me directly, feel free to email at "name@site" where
"name" is "robert" and "site" is "stuffwithstuff.com".

(C) 2008-2009 Robert Nystrom


