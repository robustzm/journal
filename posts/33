# [journal.

stuffwithstuff.com][1]

   [1]: http://journal.stuffwithstuff.com/

## me

  * [bob nystrom][2] is me
  * [bitbucket][3] has code
  * [github][4] has code
  * [flickr][5] has photos
  * [twitter][6] has status
  * [vimeo][7] has video

   [2]: http://www.stuffwithstuff.com/bob-nystrom.html
   [3]: http://bitbucket.org/munificent/
   [4]: http://github.com/munificent/
   [5]: http://www.flickr.com/photos/bobisbob/
   [6]: http://twitter.com/munificentbob
   [7]: http://vimeo.com/bobisbob

## archives

  * [2011][8]
  * [2010][9]
  * [2009][10]
  * [2008][11]

   [8]: http://journal.stuffwithstuff.com/2011/ (2011)
   [9]: http://journal.stuffwithstuff.com/2010/ (2010)
   [10]: http://journal.stuffwithstuff.com/2009/ (2009)
   [11]: http://journal.stuffwithstuff.com/2008/ (2008)

## tags

  * [blog][12] (2)
  * [c#][13] (13)
  * [code][14] (48)
  * [cpp][15] (7)
  * [design][16] (3)
  * [f#][17] (2)
  * [finch][18] (3)
  * [game-dev][19] (6)
  * [game-patterns][20] (3)
  * [go][21] (2)
  * [jasic][22] (1)
  * [java][23] (10)
  * [javascript][24] (3)
  * [language][25] (29)
  * [magpie][26] (19)
  * [optimization][27] (1)
  * [oscon][28] (1)
  * [parsing][29] (7)
  * [politics][30] (1)
  * [python][31] (2)
  * [roguelike][32] (2)
  * [ruby][33] (1)
  * [sml][34] (1)
  * [visualization][35] (1)

   [12]: http://journal.stuffwithstuff.com/category/blog/ (View all posts filed under blog)
   [13]: http://journal.stuffwithstuff.com/category/c/ (View all posts filed under c#)
   [14]: http://journal.stuffwithstuff.com/category/code/ (View all posts filed under code)
   [15]: http://journal.stuffwithstuff.com/category/cpp/ (View all posts filed under cpp)
   [16]: http://journal.stuffwithstuff.com/category/design/ (View all posts filed under design)
   [17]: http://journal.stuffwithstuff.com/category/f/ (View all posts filed under f#)
   [18]: http://journal.stuffwithstuff.com/category/finch/ (View all posts filed under finch)
   [19]: http://journal.stuffwithstuff.com/category/game-dev/ (View all posts filed under game-dev)
   [20]: http://journal.stuffwithstuff.com/category/game-patterns/ (View all posts filed under game-patterns)
   [21]: http://journal.stuffwithstuff.com/category/go/ (View all posts filed under go)
   [22]: http://journal.stuffwithstuff.com/category/jasic/ (View all posts filed under jasic)
   [23]: http://journal.stuffwithstuff.com/category/java/ (View all posts filed under java)
   [24]: http://journal.stuffwithstuff.com/category/javascript/ (View all posts filed under javascript)
   [25]: http://journal.stuffwithstuff.com/category/language/ (View all posts filed under language)
   [26]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts filed under magpie)
   [27]: http://journal.stuffwithstuff.com/category/optimization/ (View all posts filed under optimization)
   [28]: http://journal.stuffwithstuff.com/category/oscon/ (View all posts filed under oscon)
   [29]: http://journal.stuffwithstuff.com/category/parsing/ (View all posts filed under parsing)
   [30]: http://journal.stuffwithstuff.com/category/politics/ (View all posts filed under politics)
   [31]: http://journal.stuffwithstuff.com/category/python/ (View all posts filed under python)
   [32]: http://journal.stuffwithstuff.com/category/roguelike/ (View all posts filed under roguelike)
   [33]: http://journal.stuffwithstuff.com/category/ruby/ (View all posts filed under ruby)
   [34]: http://journal.stuffwithstuff.com/category/sml/ (View all posts filed under sml)
   [35]: http://journal.stuffwithstuff.com/category/visualization/ (View all posts filed under visualization)

## info

  * [famfamfam][36] provides icons
  * [RSS][37] syndicates me
  * [WordPress][38] powers me

   [36]: http://famfamfam.com/lab/icons/silk/
   [37]: feed:http://journal.stuffwithstuff.com/feed/
   [38]: http://wordpress.org/

## [Type-checking a Dynamic Language][39]

   [39]: http://journal.stuffwithstuff.com/2010/08/31/type-checking-a-dynamic-language/ (Type-checking a Dynamic Language)

[code][40] | [java][41] | [language][42] | [magpie][43] | [python][44]
[2010][45] / [08][46] / [31][47]

   [40]: http://journal.stuffwithstuff.com/category/code/ (View all posts in code)
   [41]: http://journal.stuffwithstuff.com/category/java/ (View all posts in java)
   [42]: http://journal.stuffwithstuff.com/category/language/ (View all posts in language)
   [43]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts in magpie)
   [44]: http://journal.stuffwithstuff.com/category/python/ (View all posts in python)
   [45]: http://journal.stuffwithstuff.com/2010/ (year)
   [46]: http://journal.stuffwithstuff.com/2010/08/ (month)
   [47]: http://journal.stuffwithstuff.com/2010/08/31/

If you're going down the strange path of building a language that's half-
dynamic and half-static, one obvious question you have to answer is, "When the
hell do I do the type-checking?" The general answer is, of course, "after the
types are defined, but before the program runs." This post talks about what I
think that means for Magpie.

To frame the question, lets look at a couple of other languages to see how
they work. First, Java, a typical static OOP language:

### The Two Languages of Java

If you look at a Java source file, there are almost two distinct languages
mixed together. Consider this simple program:



    public class Hello {
        public static void main() {
            Hello hello = new Hello();
            hello.say("Hello!");
        }

        public void say(String greeting) {
            System.out.println(greeting);
        }
    }


At the top level is the language of _definitions_. This language owns keywords
like `public`, `class`, and `implements`. It's used for creating types,
methods, and fields. It defines the _static_ structure and types of a program.

Nestled within that inside method bodies is the language of _statements_. This
is what we normally think of as "code": the statements that a program executes
at runtime.

In a static language, these two languages are clearly and intentionally
separated. This is important because the language of definitions is executed
at compile time, and the language of statements is executed at runtime.
Clearly delineating them in the code helps the user understand when their code
will run.

Type-checking is straightforward too. The compiler parses each source file,
and "executes" the definitions by building an internal symbol table that has
the name and definition of each class and method. Once that entire symbol
table is built, it then type-checks the method bodies (the statements) against
what's declared in that symbol table.

After that process has successfully completed, bytecode is generated and the
program runs.

### Everything is Imperative

In contrast, a dynamic language like Python only has a single language: the
language of statements. Consider this little script:



    class Hello:
        def say(self, greeting):
            print greeting

    hello = Hello()
    hello.say("Hello!")


It does pretty much the same thing as the Java program, but there's an
important distinction. Instead of having a special `main()` method that gets
invoked, we just put code at the top-level. Unlike Java, you can put regular
statements at the top level of a script: it has no definition/statement
distinction.

In fact, even the `class` bit that _looks_ like a definition, is just a
statement. It gets executed at runtime to create a class. If we moved the
`hello = Hello()` line to the top of the script, it wouldn't work. The `Hello`
class would not have been defined _yet_.

In a dynamic language, classes and types are just another thing you can create
by executing statements, at any point in the life of a program. Since there's
no type-checking anyway, it makes sense to give the user this freedom, even
though in practice most classes are created at the top-level in a fairly
static fashion.

### The Magpie Answer

So now we're back to Magpie. Magpie is primarily a dynamic language, so it
follows in Python's footsteps. There is no special definition/statement
dichotomy, and classes are created, extended, and modified imperatively at
runtime. This is a valid Magpie program and runs without any type-checking:



    class Hello
    end

    def Hello say(greeting) print(greeting)

    var hello = Hello new
    hello say("Hello!")


If we _did_ want to type-check it, only a simple change is needed (in addition
to actually adding some type annotations, of course): create a `main()`
function:



    class Hello
    end

    def Hello say(greeting String ->) print(greeting)

    var main()
        var hello = Hello new
        hello say("Hello!")
    end


This program will now type-check that the argument you pass to `hello()`
matches the declared type, `String`. It will do this _before_ `main()` is
called. So the general strategy is, if you want to write a dynamic program,
put everything at the top-level. If you want type-checking, put all of your
definitions at the top-level, and the move the code you want to run after
type-checking into `main()`.

### The Evaluation Model

More precisely, Magpie's evaluation model is:

#### 1. Evaluate the scripts dynamically

The script and any scripts it imports are executed top-down without any type-
checking. Magpie is basically a dynamic language here. (One way to look at
Magpie is as a static language with a _really_ powerful preprocessor.)

The assumption is that most of this code will be defining classes, methods,
and functions and binding them to global variables, but you can do anything
you want here, including writing entire programs if you don't care to type-
check.

#### 2. Type-check

Once the interpreter has finished evaluating the scripts, it looks in the
global scope to see if you've defined a function called `main()`. Doing so is
the trigger that says, "I want to type-check."

If it finds it, it then type-checks everything that's defined in global scope:
classes, their methods, and functions. (In other words, Magpie uses the global
scope as compiler's symbol table.) If there are errors, it will print them out
here and stop. Otherwise…

#### 3. Run `main()`

Assuming there weren't any type errors, now it will call `main()` which can
then instantiate classes, call functions, or do whatever, safe in the
knowledge that we won't get here unless all of the type checks passed.

### What Happens if You Cheat?

Astute readers at this point have noticed a problem. If we can imperatively
modify classes at any point, and we can execute any imperative code after
type-checking, then what's to prevent us from modifying a class after it's
been type-checked into something that will no longer work? For example:



    class Foo
    end

    Foo bar() print "called bar"

    var main(->)
        // break Foo!
        Foo removeMethod("bar")

        // now try to call it!
        var foo = Foo new
        foo bar
    end


When `main()` is type-checked, `Foo` has a method called `bar` so it looks
fine. But by the time we get to executing it, we've actually yanked that
method out and the call will fail. Uh-oh!

Thankfully, this isn't the end of the world. Because Magpie is dynamic, this
won't trash memory or go off into the weeds like a static language. You'll
just get a "method not found" error at runtime.

But the bigger question is, how should we address this situation? I've got
three options I'm considering:

  1. **Don't worry about it.** This is the current solution. Acknowledge that users can break things, but trust that they won't. This is pretty much how every dynamic language works, and yet programmers manage to survive. Magpie's philosophy is "better type-checking than a dynamic language", not "perfect bullet-proof type-checking", so this fits.
  2. **Don't allow classes to be modified in ways that can break type-checking.** This is a safer solution that takes a little power from programmers. Magpie could allow you to add methods to a class, but not _remove_ them once added. That would ensure that you can't imperatively break a class's type guarantee after it's been checked.
  3. **Freeze classes after type-checking.** This is the strictest solution. Once a class has been type-checked, mark it as frozen. After that, any attempts to modify it at runtime would fail. You could create new unfrozen classes after type-checking, but everything that's gone through the checker gets locked down.

I'm leaning towards the first option because it's simplest and most flexible,
but I'm open to thoughts one way or the other.

### Thoughts?

So that's what I came up with. The code that's structured like a dynamic
language runs dynamically. The code that's called from `main()` runs after
type-checking like a static language. The implementation is still very rough,
but it seems to actually kind of work, strangely enough.

Discuss this at one of the sites below (or another of your choice):

[ ![][48]][49]

   [48]: http://cdn.stumble-upon.com/images/120x20_su_white.gif
   [49]: http://www.stumbleupon.com/submit?url=http://journal.stuffwithstuff.com%26title%3DThe%2BArticle%2BTitle

If you want to contact me directly, feel free to email at "name@site" where
"name" is "robert" and "site" is "stuffwithstuff.com".

(C) 2008-2009 Robert Nystrom


