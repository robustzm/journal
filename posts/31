# [journal.

stuffwithstuff.com][1]

   [1]: http://journal.stuffwithstuff.com/

## me

  * [bob nystrom][2] is me
  * [bitbucket][3] has code
  * [github][4] has code
  * [flickr][5] has photos
  * [twitter][6] has status
  * [vimeo][7] has video

   [2]: http://www.stuffwithstuff.com/bob-nystrom.html
   [3]: http://bitbucket.org/munificent/
   [4]: http://github.com/munificent/
   [5]: http://www.flickr.com/photos/bobisbob/
   [6]: http://twitter.com/munificentbob
   [7]: http://vimeo.com/bobisbob

## archives

  * [2011][8]
  * [2010][9]
  * [2009][10]
  * [2008][11]

   [8]: http://journal.stuffwithstuff.com/2011/ (2011)
   [9]: http://journal.stuffwithstuff.com/2010/ (2010)
   [10]: http://journal.stuffwithstuff.com/2009/ (2009)
   [11]: http://journal.stuffwithstuff.com/2008/ (2008)

## tags

  * [blog][12] (2)
  * [c#][13] (13)
  * [code][14] (48)
  * [cpp][15] (7)
  * [design][16] (3)
  * [f#][17] (2)
  * [finch][18] (3)
  * [game-dev][19] (6)
  * [game-patterns][20] (3)
  * [go][21] (2)
  * [jasic][22] (1)
  * [java][23] (10)
  * [javascript][24] (3)
  * [language][25] (29)
  * [magpie][26] (19)
  * [optimization][27] (1)
  * [oscon][28] (1)
  * [parsing][29] (7)
  * [politics][30] (1)
  * [python][31] (2)
  * [roguelike][32] (2)
  * [ruby][33] (1)
  * [sml][34] (1)
  * [visualization][35] (1)

   [12]: http://journal.stuffwithstuff.com/category/blog/ (View all posts filed under blog)
   [13]: http://journal.stuffwithstuff.com/category/c/ (View all posts filed under c#)
   [14]: http://journal.stuffwithstuff.com/category/code/ (View all posts filed under code)
   [15]: http://journal.stuffwithstuff.com/category/cpp/ (View all posts filed under cpp)
   [16]: http://journal.stuffwithstuff.com/category/design/ (View all posts filed under design)
   [17]: http://journal.stuffwithstuff.com/category/f/ (View all posts filed under f#)
   [18]: http://journal.stuffwithstuff.com/category/finch/ (View all posts filed under finch)
   [19]: http://journal.stuffwithstuff.com/category/game-dev/ (View all posts filed under game-dev)
   [20]: http://journal.stuffwithstuff.com/category/game-patterns/ (View all posts filed under game-patterns)
   [21]: http://journal.stuffwithstuff.com/category/go/ (View all posts filed under go)
   [22]: http://journal.stuffwithstuff.com/category/jasic/ (View all posts filed under jasic)
   [23]: http://journal.stuffwithstuff.com/category/java/ (View all posts filed under java)
   [24]: http://journal.stuffwithstuff.com/category/javascript/ (View all posts filed under javascript)
   [25]: http://journal.stuffwithstuff.com/category/language/ (View all posts filed under language)
   [26]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts filed under magpie)
   [27]: http://journal.stuffwithstuff.com/category/optimization/ (View all posts filed under optimization)
   [28]: http://journal.stuffwithstuff.com/category/oscon/ (View all posts filed under oscon)
   [29]: http://journal.stuffwithstuff.com/category/parsing/ (View all posts filed under parsing)
   [30]: http://journal.stuffwithstuff.com/category/politics/ (View all posts filed under politics)
   [31]: http://journal.stuffwithstuff.com/category/python/ (View all posts filed under python)
   [32]: http://journal.stuffwithstuff.com/category/roguelike/ (View all posts filed under roguelike)
   [33]: http://journal.stuffwithstuff.com/category/ruby/ (View all posts filed under ruby)
   [34]: http://journal.stuffwithstuff.com/category/sml/ (View all posts filed under sml)
   [35]: http://journal.stuffwithstuff.com/category/visualization/ (View all posts filed under visualization)

## info

  * [famfamfam][36] provides icons
  * [RSS][37] syndicates me
  * [WordPress][38] powers me

   [36]: http://famfamfam.com/lab/icons/silk/
   [37]: feed:http://journal.stuffwithstuff.com/feed/
   [38]: http://wordpress.org/

## [Class in the Front, Proto in the Back][39]

   [39]: http://journal.stuffwithstuff.com/2010/08/01/class-in-the-front-proto-in-the-back/ (Class in the Front, Proto in the Back)

[code][40] | [java][41] | [language][42] | [magpie][43] [2010][44] / [08][45]
/ [01][46]

   [40]: http://journal.stuffwithstuff.com/category/code/ (View all posts in code)
   [41]: http://journal.stuffwithstuff.com/category/java/ (View all posts in java)
   [42]: http://journal.stuffwithstuff.com/category/language/ (View all posts in language)
   [43]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts in magpie)
   [44]: http://journal.stuffwithstuff.com/2010/ (year)
   [45]: http://journal.stuffwithstuff.com/2010/08/ (month)
   [46]: http://journal.stuffwithstuff.com/2010/08/01/

Inspired by what I learned and saw at the [Emerging Languages Camp][47], I've
started working on [Magpie][48] again. It's more or less been dormant while I
figured out what kind of language I wanted it to be.

   [47]: http://emerginglangs.com/
   [48]: http://bitbucket.org/munificent/magpie

One big change is that Magpie Redux is going to be object-oriented where the
original Magpie was procedural. Magpie was an experiment to see if a
procedural language can be as nice to use as an OOP one if you give it memory
management and a decent type system. For my purposes, the answer was that it's
not too bad, but objects are really nice to have.

So I started working on a fresh Magpie interpreter in Java that's class-based
and dynamically-typed. (As a nice bonus, Magpie going forward won't be as tied
to the MS stack as [the old C# one][49] is.) This post is about one
implementation detail I think is kind of interesting: _even though Magpie-the-
language is class-based, under the hood, the interpreter uses prototypes._

   [49]: http://bitbucket.org/munificent/magpie/src/tip/csharp/

### What's in a Class?

Before we get too far, let's make sure we're all talking about the same thing.
In Magpie, all objects are instances of a class. The class determines what
methods an object has. The pseudocode for invoking a method is:



    invoke(obj, methodName, arg)
        class = obj.getClass
        method = class.findMethod(methodName)
        method.invoke(obj, arg)
    end


Under the hood then, a class is a bag of methods, something like:



    class ClassObj {
        Map<String, Method> methods;
    }


And an object is just a reference to its class (and some data, but we won't
worry about that here):



    class Obj {
        ClassObj theClass;
    }


However, there are actually _two_ kinds of methods. There are regular instance
methods, like we've seen and "static" or "class" methods that you invoke
directly on the class. These include things like constructors (which are like
Ruby's [new][50] methods). For example:


       [50]: http://www.devx.com/enterprise/Article/30917/0/page/3

    def foo = Foo.new   // call a class method on Foo
    foo.toString        // call an instance method on a Foo


So our class object really needs _two_ dictionaries, one for class and one for
instance methods:



    class ClassObj {
        Map<String, Method> classMethods;
        Map<String, Method> instanceMethods;
    }


It also ends up needing to duplicate the API for using them: separate methods
for defining a method, looking one up, invoking one, etc. I _[hate][51]_
redundancy so this rubbed me the wrong way.

   [51]: http://en.wikipedia.org/wiki/DRY

### Split-aparts

Instead of having a single class object that does _two_ things, I thought why
not split that up into two separate objects? One represents the _class itself_
and has the static or class methods like constructors. The other represents
the set of methods you can call on an _instance_ of the class.

My `ClassObj` type disappeared, to just be:



    class Obj {
        Map<String, Method> methods;
    }


The only missing piece was that an instance of some object needed to have a
reference to the other object that contains its methods, like so:



    class Obj {
        Obj parent;
        Map<String, Method> methods;
    }


Now our pseudo-code for invoking a method is:



    invoke(obj, methodName, arg)
        thisObj = obj
        loop
            method = thisObj.findMethod(methodName)
            if method != null then
                return method.invoke(obj, arg)
            end
            // walk up the parent chain
            thisObj = obj.parent
        end
    end


You'll note that this pseudocode handles _both_ instance and class methods.
With instance methods, `obj` will be the class object itself (since classes
are first-class objects) and it will find the method and immediately invoke
it.

With instance methods, the object's parent will be the special object that
holds all of the instance methods. So we'll fail to find the method on the
object itself, walk up to its parent, find it and be done.

### Familiar?

This started to look pretty familiar. I had an object that represented a
class, and another object that represented the methods all objects of that
class have in common. There's a name for that second object: a _prototype_. In
the name of getting rid of duplicate code, I basically stumbled backwards onto
the same type system that Javascript and [Finch][52] use.

   [52]: http://finch.stuffwithstuff.com/

The interesting part is that this is hidden completely from the user. Magpie
code is still written using classes and instances. If you have this in Magpie:



    class Foo
        def sayHi () print "hi"
    end

    def a = Foo.new
    def b = Foo.new
    a.sayHi
    b.sayHi


At runtime, the interpreter will build this object hierarchy:

![Object hierarchy for a class Foo and two instances of it][53]

   [53]: http://journal.stuffwithstuff.com/wp-content/uploads/2010/08/prototype-hierarchy.png (Object Hierarchy)

Every box represents an object and is of the same Java class in the
interpreter (`Obj`). Objects `a` and `b` both have `Foo proto` as their
parent, which is the prototype object holding the instance methods. The class
methods like `new` are held in a separate object `Foo class` representing the
class itself and bound to the variable `Foo`.

The class and proto objects don't have each other as parents because they
aren't directly related (i.e. there's no "is-a" relationship between them).
Instead, the class stores a reference to the prototype in a "proto" field so
that it can find it when it needs to create new instances. Conversely, the
prototype stores a reference to the class so that it can find it when you ask
an instance what its class is.

Doing things this way let me simplify a lot of the underlying code while still
having the convenience of classes at the user level. This is the best of both
worlds: prototypes are easier for the language implementer to code and classes
are easier for the user to use.

Of course, I still have a ton of work to do before Magpie is anywhere near
usable again and this may all be nullified by something I run into along the
way, but so far it seems to be working.

Discuss this at one of the sites below (or another of your choice):

[ ![][54]][55]

   [54]: http://cdn.stumble-upon.com/images/120x20_su_white.gif
   [55]: http://www.stumbleupon.com/submit?url=http://journal.stuffwithstuff.com%26title%3DThe%2BArticle%2BTitle

If you want to contact me directly, feel free to email at "name@site" where
"name" is "robert" and "site" is "stuffwithstuff.com".

(C) 2008-2009 Robert Nystrom


