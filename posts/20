# [journal.

stuffwithstuff.com][1]

   [1]: http://journal.stuffwithstuff.com/

## me

  * [bob nystrom][2] is me
  * [bitbucket][3] has code
  * [github][4] has code
  * [flickr][5] has photos
  * [twitter][6] has status
  * [vimeo][7] has video

   [2]: http://www.stuffwithstuff.com/bob-nystrom.html
   [3]: http://bitbucket.org/munificent/
   [4]: http://github.com/munificent/
   [5]: http://www.flickr.com/photos/bobisbob/
   [6]: http://twitter.com/munificentbob
   [7]: http://vimeo.com/bobisbob

## archives

  * [2011][8]
  * [2010][9]
  * [2009][10]
  * [2008][11]

   [8]: http://journal.stuffwithstuff.com/2011/ (2011)
   [9]: http://journal.stuffwithstuff.com/2010/ (2010)
   [10]: http://journal.stuffwithstuff.com/2009/ (2009)
   [11]: http://journal.stuffwithstuff.com/2008/ (2008)

## tags

  * [blog][12] (2)
  * [c#][13] (13)
  * [code][14] (48)
  * [cpp][15] (7)
  * [design][16] (3)
  * [f#][17] (2)
  * [finch][18] (3)
  * [game-dev][19] (6)
  * [game-patterns][20] (3)
  * [go][21] (2)
  * [jasic][22] (1)
  * [java][23] (10)
  * [javascript][24] (3)
  * [language][25] (29)
  * [magpie][26] (19)
  * [optimization][27] (1)
  * [oscon][28] (1)
  * [parsing][29] (7)
  * [politics][30] (1)
  * [python][31] (2)
  * [roguelike][32] (2)
  * [ruby][33] (1)
  * [sml][34] (1)
  * [visualization][35] (1)

   [12]: http://journal.stuffwithstuff.com/category/blog/ (View all posts filed under blog)
   [13]: http://journal.stuffwithstuff.com/category/c/ (View all posts filed under c#)
   [14]: http://journal.stuffwithstuff.com/category/code/ (View all posts filed under code)
   [15]: http://journal.stuffwithstuff.com/category/cpp/ (View all posts filed under cpp)
   [16]: http://journal.stuffwithstuff.com/category/design/ (View all posts filed under design)
   [17]: http://journal.stuffwithstuff.com/category/f/ (View all posts filed under f#)
   [18]: http://journal.stuffwithstuff.com/category/finch/ (View all posts filed under finch)
   [19]: http://journal.stuffwithstuff.com/category/game-dev/ (View all posts filed under game-dev)
   [20]: http://journal.stuffwithstuff.com/category/game-patterns/ (View all posts filed under game-patterns)
   [21]: http://journal.stuffwithstuff.com/category/go/ (View all posts filed under go)
   [22]: http://journal.stuffwithstuff.com/category/jasic/ (View all posts filed under jasic)
   [23]: http://journal.stuffwithstuff.com/category/java/ (View all posts filed under java)
   [24]: http://journal.stuffwithstuff.com/category/javascript/ (View all posts filed under javascript)
   [25]: http://journal.stuffwithstuff.com/category/language/ (View all posts filed under language)
   [26]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts filed under magpie)
   [27]: http://journal.stuffwithstuff.com/category/optimization/ (View all posts filed under optimization)
   [28]: http://journal.stuffwithstuff.com/category/oscon/ (View all posts filed under oscon)
   [29]: http://journal.stuffwithstuff.com/category/parsing/ (View all posts filed under parsing)
   [30]: http://journal.stuffwithstuff.com/category/politics/ (View all posts filed under politics)
   [31]: http://journal.stuffwithstuff.com/category/python/ (View all posts filed under python)
   [32]: http://journal.stuffwithstuff.com/category/roguelike/ (View all posts filed under roguelike)
   [33]: http://journal.stuffwithstuff.com/category/ruby/ (View all posts filed under ruby)
   [34]: http://journal.stuffwithstuff.com/category/sml/ (View all posts filed under sml)
   [35]: http://journal.stuffwithstuff.com/category/visualization/ (View all posts filed under visualization)

## info

  * [famfamfam][36] provides icons
  * [RSS][37] syndicates me
  * [WordPress][38] powers me

   [36]: http://famfamfam.com/lab/icons/silk/
   [37]: feed:http://journal.stuffwithstuff.com/feed/
   [38]: http://wordpress.org/

## [Conditional Binding with "let" in Magpie][39]

   [39]: http://journal.stuffwithstuff.com/2009/12/26/conditional-binding-with-let-in-magpie/ (Conditional Binding with &#8220;let&#8221; in Magpie)

[code][40] | [language][41] | [magpie][42] [2009][43] / [12][44] / [26][45]

   [40]: http://journal.stuffwithstuff.com/category/code/ (View all posts in code)
   [41]: http://journal.stuffwithstuff.com/category/language/ (View all posts in language)
   [42]: http://journal.stuffwithstuff.com/category/magpie/ (View all posts in magpie)
   [43]: http://journal.stuffwithstuff.com/2009/ (year)
   [44]: http://journal.stuffwithstuff.com/2009/12/ (month)
   [45]: http://journal.stuffwithstuff.com/2009/12/26/

Magpie, as an imperative language, has the usual flow control structures you
expect to see: `while`, `if`, and `for` (although they're a little different
from their C counter-parts). However, Magpie has one other flow control
construct you probably haven't seen before: `let then`, the conditional
binder.

### A Motivating Example or Two

Before I explain it, let's go over a couple of examples in other languages
where it would be useful. First up: converting strings to other types. In C#,
you'd do something like:



    int value = Int32.Parse("1234");
    // do something with value


That's fine and dandy except that the parse can fail and throw an exception.
If you don't want to deal with the exception, the easier solution is to use
the conveniently provided `TryParse` function:



    int value;
    if (Int32.TryParse("1234", out value))
    {
        // do something with value
    }


That's the idiomatic way to convert strings to ints in C#. Aside from the
cumbersome out parameter, what's lame about it is that `value` is scoped
_outside_ of the `if` block where we actually want to use it. If the
conversion fails, we have this weird unassigned `value` variable floating
around.

Here's another example: downcasting. Let's say we have a variable of type
`Base` and we want to downcast it to a `Derived` subclass. The normal way to
do this is:



    Derived derived = someBase as Derived;
    if (derived != null)
    {
        // do something with derived
    }


A third and final example: looking up a value in a dictionary. If you aren't
sure the key exists, the typical solution is:



    Dictionary<string, int> dict = // get dictionary...

    int value;
    if (dict.TryGetValue("key", out value))
    {
        // do something with value
    }


You're seeing the pattern by now. All of these have the exact same structure.
We have some operation that may return a value or may fail for some reason. If
it succeeds, we want to do something with the returned value.

### Let

The `let` keyword in Magpie lets you implement that pattern directly, without
the gross scoping issues or output parameters. The above examples in Magpie
would look like:



    // parse
    let value <- "1234".AsInt then
        // do something with value
    end

    // downcast
    let derived <- someBase.As'Derived then
        // do something with derived
    end

    // look up in dictionary
    let value <- Find (dict, "key") then
        // do something with value
    end


The way this works is pretty simple. Magpie has an `Option` type, which is the
same as F#'s [option][46] or Haskell's [Maybe][47]. A `let` expression looks
like:


       [46]: http://msdn.microsoft.com/en-us/library/dd233245%28VS.100%29.aspx
   [47]: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Maybe

    let <variable> <- <expression> then <body>


The `<expression>` is expected to return an Option value. If it evaluates to
`Some`, then the value is extracted and assigned to `<variable>` and the
`<body>` is evaluated. If `None` is returned instead, the variable isn't bound
and the body is skipped. Pretty straightforward.

What's nice about it is that the bound variable is scoped to the _body_ of the
`let` expression and disappears afterwards. This means that if the expression
fails and returns `None`, the variable disappears entirely. It's syntactically
impossible to access that variable incorrectly when the expression fails.

### What Else?

Because `let` is essentially another kind of `if`, it also supports an `else`
clause:



    // parse
    let value <- "1234".AsInt then
        // do something with value
    else
        Print "Couldn't parse string."
    end


### A Bit on Naming

I probably spend more time than I should thinking about the minutia of
language syntax. I chose `let` because to me that implies _permission_: it
_may_ "let" you do something or it may not, which lines up with the
conditional nature of the construct. Using `then` to separate the expression
from the body both

reinforces that this is an "if-like" conditional block and lets me

reuse an existing keyword.

Of course, programmers of the ML-family will likely recognize `let` as a poor
man's pattern matching. This isn't far from the truth, but I do think Magpie's
"light" version is kind of nice in its own regard.

Discuss this at one of the sites below (or another of your choice):

[ ![][48]][49]

   [48]: http://cdn.stumble-upon.com/images/120x20_su_white.gif
   [49]: http://www.stumbleupon.com/submit?url=http://journal.stuffwithstuff.com%26title%3DThe%2BArticle%2BTitle

If you want to contact me directly, feel free to email at "name@site" where
"name" is "robert" and "site" is "stuffwithstuff.com".

(C) 2008-2009 Robert Nystrom


